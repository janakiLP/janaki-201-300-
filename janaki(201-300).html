<html>
    <head>
        <title>Pages</title>
        <link rel="stylesheet" href="book.css">
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.0/css/bootstrap.min.css">
        <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>
        <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.0/js/bootstrap.min.js"></script>
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
       <link rel="stylesheet" href= "https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">   
       <link rel="stylesheet" media="all and (max-width:480px)" href="book.css">
       
    </head>
    <body>
        <p class="b">place notification blocks on the queue. Applications and methods can delete<br>
            notification queues by deleting the EKG_NotificationQueue object using the<br>
            EKG_DeleteObject function. When it creates the queue, RODM automatically<br>
            qualifies the name of any notification queue with the User_appl_ID from the access<br>
            block. Each notification queue created with a particular User_appl_ID must be<br>
            unique.</p>
        <p class="b">Table 21 describes the fields of the EKG_NotificationQueue class, the access for<br>
            each field, the data type, and the subfields defined for each field.</p>
        <p><i>Table 21. EKG_NotificationQueue Fields</i></p>
        <table class="tab" border="2">
            <tr><th>Field Name</th><th>Access</th><th>Data Type</th><th>Query</th><th>Change</th><th>Notify</th><th>Time<br>stamp</th></tr>
            <tr><td>EKG_Status</td><td>Write</td><td>Enumerated Smallint</td><td></td><td></td><td>X</td><td>X</td></tr>
            <tr><td>EKG_ECBAddress</td><td>Write</td><td>ECBAddress</td><td></td><td></td><td></td><td>X</td></tr>
            <tr><td>EKG_ECBPostedStatus</td><td>Read</td><td>Enumerated Smallint</td><td></td><td></td><td>X</td><td></td></tr>
            <tr><td>EKG_UsedBy</td><td>Read</td><td>ObjectLink</td><td></td><td></td><td></td><td></td></tr>
            <tr><td>EKG_SubscribedFromClass</td><td>Read</td><td>ClassLinkList</td><td></td><td></td><td></td><td></td></tr>
            <tr><td>EKG_SubscribedFromObject</td><td>Read</td><td>ObjectLinkList</td><td></td><td></td><td></td><td></td></tr>
            <tr><td>EKG_Maximum_Q_Entries</td><td>Write</td><td>Integer</td><td></td><td></td><td>X</td><td></td></tr>
            <tr><td>EKG_MessagesOnQueue</td><td>Read</td><td>Integer</td><td></td><td></td><td></td><td></td></tr>
            <tr><td>EKG_SubscribedForDelete</td><td>Read</td><td>ObjectIDList</td><td></td><td></td><td></td><td></td></tr>

               
        </table>
        <p class="a">The field definitions are as follows:</p>
        <h4 class="heading">EKG_Status</h4>
        <p class="b">The status of the notification queue. The following values are valid</p>
        <p class="a"><table class="b">
            <tr><th>Value</th><th>Meaning</th></tr>
            <tr><td>0</td><td>Inactive</td></tr>
            <tr><td>1</td><td>Active</td></tr>
        </table></p>
        <p class="b">Active status causes RODM to attach notifications to this queue regardless of<br>
            the ECB value. If a queue accumulates entries when no ECB has been<br>
            established, RODM posts the ECB as soon as the application sets an ECB<br>
            value.</p>
        <p class="b">Inactive status causes RODM to not attach notifications even if the ECB is<br>
            already set. This field has a default value of active except in the following<br>
            situation. User_A creates a notification queue for User_B and there is no user<br>
            object for User_B. RODM creates the required objects, sets EKG_Status in the<br>
            NotificationQueue object to inactive, and sets the EKG_Status of the user object<br>
            to disconnected.</p>
        <h4 class="heading">EKG_ECBAddress</h4>
        <p class="b">The address of an ECB. This is the address of the optional ECB that is posted<br>
            when a notification block is added to this notification queue. The ECB is<br>
            created in the address space of the user application that is using this<br>
            notification queue.</p>
      <h4 class="heading">EKG_ECBPostedStatus</h4>
      <p class="b">
        Posted status. Valid values are as follows:</p>
        <p class="a"><table >
            <tr><th>Value</th><th>Meaning</th></tr>
            <tr><td>0</td><td>False</td></tr>
            <tr><td>1</td><td>True</td></tr>
        </table></p>
        <p class="b">This field is set to true if the application has been posted and the queue is not<br>
            empty. This field is set to false when the queue is empty.</p>
        <h4 class="heading">EKG_UsedBy</h4>
        <p class="b">This field specifies the user that created this notification queue.</p>
        <h4 class="heading">EKG_SubscribedFromClass</h4>
        <p class="b">This field is a list of classes that have a subscription to this notification queue.<br>
            The field is a one-way link.</p>
        <p class="b">The field has a data type of ClassLinkList; each list item consists of a ClassID<br>
            and a FieldID. The field referenced by the FieldID contains subscription<br>
            information in the form of a RecipientSpec data type. The RecipientSpec data<br>
            type contains an 8-byte SubscribeID that your application can use to locate the<br>
            notification queue object. For information about these data types, see “Abstract<br>
            Data Type Reference” on page 219.</p>
        <h4 class="heading">EKG_SubscribedFromObject</h4>
        <p class="b">This field is a list of objects that have a subscription to this notification queue.<br>
            The field is a one-way link.
            </p>
        <p class="b">The field has a data type of ObjectLinkList; each list item consists of an<br>
            ObjectID and a FieldID. The field referenced by the FieldID contains<br>
            subscription information in the form of the RecipientSpec data type. The<br>
            RecipientSpec data type contains an 8-byte SubscribeID that your application<br>
            can use to locate the notification queue object. For information about these<br>
            data types, see “Abstract Data Type Reference” on page 219.</p>
        <h4 class="heading">EKG_MessagesOnQueue</h4>
        <p class="b">The number of messages currently on the EKG_NotificationQueue.
        </p>
        <h4 class="heading">EKG_Maximum_Q_Entries</h4>
        <p class="b">The maximum number of entries permitted on the EKG_NotificationQueue.<br>
            You can use this field to limit the amount of RODM storage used for unread<br>
            notifications. When the number of messages on the EKG_NotificationQueue<br>
            reaches the value of EKG_Maximum_Q_Entries, RODM does not place any<br>
            more messages on the queue. RODM issues return code 4 with reason code 158<br>
            to the notification method which explains that the message cannot be placed<br>
            on the queue.</p>
        <p class="b">The default setting of this field is -1, which indicates no limit.</p>
        <h4 class="heading">EKG_SubscribedForDelete</h4>
        <p class="b">This field is a list of objects that have an object-deletion subscription to this<br>
            notification queue.</p>
        <p class="b">The field has a data type of ObjectIDList; each list item consists of an ObjectID.<br>
            For information about these data types, see “Abstract Data Type Reference” on<br>
            page 219.</p>
     <h3 class="heading">EKG_SubscribedForDelete</h3>
     <p class="heading">EKG_Method is the class of all RODM methods.</p>
     <p class="heading">The parent of EKG_Method class is EKG_SystemDataParent class.
    </p>
    <p class="heading">Before your application program can refer to a method in a function request or<br>
        trigger a method, the method must:
        </p>
        <p class="a"> <ul><li>Have an object of the EKG_Method class that represents it</li></ul></p>
        <p class="a"> <ul><li>Be present in memory or you must load it into memory through a method<br>
            installation process</li></ul></p>
        <p class="a">If RODM cannot find or load the method, it generates an error return code. For<br>
            more information about installing methods, see “Installing and Freeing Methods”<br>
            on page 360.</p>
        <p class="a">When a method object is created, that method name is made executable for both<br>
            user API and method API functions. A method has different available functions or<br>
            different abilities to access data depending on whether it is an object-specific<br>
            method or an object-independent method. You can write a method that is both an<br>
            object-specific method and an object-independent method.</p>
        <p class="a">The object name of the EKG_Method object you create is the same as the name of<br>
            the method you are installing. You can identify all installed methods by querying<br>
            the EKG_Method class using the EKG_QueryEntityStructure function.</p>
        <p class="a">The null method that is supplied with the NetView program, NullMeth, is not<br>
            installed by user creation of an object. This method is built into RODM.</p>
        <p class="a">You also use an object of the RODM Method class during the refreshing of the<br>
            method. Refreshing is accomplished by using the EKG_TriggerNamedMethod<br>
            function to invoke the method indicated by the EKG_Refresh field in the method<br>
            object of the method which is to be refreshed. Refreshing deletes the old copy of<br>
            the method from memory and loads a new copy of the method for all future<br>
            references.</p>
        <p class="a">You can create or delete all fields of EKG_Method.</p>
        <p class="a">Table 22 describes the fields of EKG_Method class, the access for each field, the<br>
            data type, and the applicable operations.</p>
        <p class="a"><i>Table 22. EKG_Method Fields</i></p>
        <p class="a"><table border="2">
            <tr><th>Field Name</th><th>Access</th><th>Data Type</th><th>Query</th><th>Change</th><th>Notify</th><th>Time<br>stamp</th></tr>
            <tr><td>EKG_InstallerID</td><td>Read</td><td>CharVar</td><td></td><td></td><td></td><td>X</td></tr>
            <tr><td>EKG_UsageCount</td><td>Read</td><td>Integer</td><td></td><td></td><td></td><td></td></tr>
            <tr><td>EKG_Refresh</td><td>Read</td><td>MethodSpec</td><td></td><td></td><td></td><td></td></tr>
            <tr><td>EKG_MTraceFlag</td><td>Write</td><td>Integer</td><td></td><td></td><td></td><td>X</td></tr>

        </table></p>
        <p class="a">The field definitions are as follows:</p>
        <h4 class="heading">EKG_InstallerID</h4>
        <p class="b">The user ID associated with the installation of the method. The timestamp<br>
            subfield indicates when the method was installed.</p>
            <h4 class="heading">EKG_UsageCount</h4>
        <p class="b">The current number of references of this method from notify, change, and<br>
            query subfields, and from value subfields used for named methods. When you<br>
            delete an object of the EKG_Method class, the usage count, EKG_UsageCount,<br>
            must be zero. When you refresh an object of the EKG_Method class, there is no<br>
            restriction on value of EKG_UsageCount.</p>
            <h4 class="heading">EKG_Refresh</h4>
        <p class="b">The name of an internal RODM refresh method that must be invoked to<br>
            refresh the method represented by the method object. If an application queries<br>
            the EKG_Refresh value subfield, RODM returns a null value for the Object_ID<br>
            field of the MethodSpec data.</p>
        <p class="b">When the refresh method is triggered using the EKG_TriggerNamedMethod<br>
            API, RODM loads a new copy of the method from the method library. The<br>
            Method_parms field of the EKG_TriggerNamedMethod function block is not<br>
            used by the refresh method.</p>
        <p class="b">A method can be refreshed even though it is currently referenced in notify, <br>
            change, or query subfields. The refresh operation will wait until the method is <br>
            not executing before loading the new copy of the method. Subsequent <br>
            executions of the method are suspended until the new copy has been loaded.</p>
            <h4 class="heading">EKG_MTraceFlag</h4>
            <p class="b">Specific method trace enable flag. This field specifies if the method is enabled<br>
                for tracing. Valid values are as follows:</p>
               <p class="a"> <table class="b" >
                    <tr><th>Value</th><th>Meaning</th></tr>
                    <tr><td>0</td><td>Defers the trace decision to EKG_MTraceType.</td></tr>
                    <tr><td>1</td><td>Ensures tracing.</td></tr>
                </table></p>
            <p class="b">The initial value is 0.</p>
            <p class="b">Tracing must also be enabled by the EKG_MTraceType field in the EKG_User<br>
                class before RODM can trace this method.</p>
            <p class="a"><b class="bold">Deleting an Object of the EKG_Method Class: </b>Deleting a method object checks<br>
                whether the specified method is assigned to any field or subfield as a named,<br>
                change, query, or notify method. If not, the method is removed from RODM's<br>
                active methods and the corresponding load module can be freed from memory</p>
            <p class="a">If the method is an object-specific method and is referenced by one or more fields,<br>
                then it cannot be deleted until all such references are first removed. To remove<br>
                these references to an object-specific method prior to deleting a method:</p>
            <p class="a"><ul><li> Change the fields that have a data type of MethodSpec and reference the<br>
                object-specific method to the null value (NullMeth) using the EKG_ChangeField<br>
                or EKG_ChangeMultipleFields functions.</li></ul></p>
            <p class="a"><ul><li>Change all subfield that have a data type of MethodSpec and reference the<br>
                object-specific method to the null value (NullMeth) using the<br>
                EKG_ChangeSubfield function.</li></ul></p>
            <p class="a"><ul><li>v Remove the notification subscriptions for the notification method using the<br>
                EKG_DeleteNotifySubscription function.</li></ul></p>
                <hr class="hr">
            <h2>RODM Objects</h2>
            <p class="a">Objects are the basic units of data in RODM. They are organized by class and<br>
                represented by a name containing up to 254 characters. Objects can represent<br>
                real-world objects, such as DASD devices or printers. Objects can also represent<br>
                management objects, such as a view on a graphical display, operator access<br>
                authority, or an application program. Objects can contain locally defined data or<br>
                inherit data from a class.</p>
            <p class="a">User applications and object-independent methods can create objects using the<br>
                EKG_CreateObject function. You can also create objects using the RODM load<br>
                function. When you create an object, you specify the name of the object and the<br>
                class to which the object belongs. RODM returns the numerical object identifier of<br>
                the new object. The object inherits the public fields that are defined on the class to<br>
                which the object belongs.</p>
            <h3 class="heading1">Object Names</h3>
            <p class="a">Each RODM object has a character string name in its MyName field called the<br>
                <i>object name.</i></p>
            <p class="a">Two objects, each in a separate class, can have the same object name. Each object<br>
                can be accessed with the combination of its class name and object name in the<br>
                form Class_Name.Object_Name.</p>
            <p class="a">RODM system-defined object names are reserved by RODM and cannot be deleted<br>
                by the user.</p>
            <p class="a">RODM assigns an object name to any object you create if you do not specify a<br>
                name when you create the object. RODM assigns names of the form EKG<i>ddddddd,</i> <br>
                where <i>ddddddd </i>ranges from 0000000 to 9999999, starting with EKG0000001. Note<br>
                that values in this range are for RODM use only. </p>
            <p class="a">If you are creating an object of the EKG_Method class or the<br>
                EKG_NotificationQueue class, the object name is limited to 8 characters. For the<br>
                EKG_NotificationQueue class, if the user ID and object name are combined to<br>
                produce a fully qualified notification queue name in the form<br>
                User_appl_ID.object_name, the resulting fully qualified notification queue name is<br>
                limited to 17 characters, including the separating period.</p>
            <p class="a">The CHARACTER_VALIDATION keyword in EKGCUST specifies what degree of<br>
                validity checking RODM performs for characters used in class names (see “Class<br>
                Names” on page 191), field names (see “Field Names” on page 206), and object<br>
                names.</p>
            <h4 class="heading">Object Name Characteristics with<br>
                CHARACTER_VALIDATION(YES)</h4>
            <p class="a">When CHARACTER_VALIDATION(YES), which is the default, is coded in<br>
                EKGCUST, valid object names have the following characteristics:</p>
            <ul class="a">
                <li>v The name consists of 1 to 254 characters with an abstract data type of<br>
                    ObjectName that conforms to the PL/I syntax of CHAR(254) VARYING</li>
                <li>The first character of the string must be alphabetic or numeric. The others, if<br>
                    any, can be alphabetic, numeric, or any of the special characters: # @ . , : ; ? ( ) ' "<br>
                    - _ & + % * = < > /</li>
                <li>Both uppercase and lowercase alphabetic characters are permitted, and names<br>
                    are case-sensitive.</li>
                <li>The EKG_ prefix is reserved for RODM-created classes and objects. Do not use<br>
                    this prefix in the names of classes or objects that you create.</li>
                <li>v EKG<i>xxxxxxx</i> (EKG followed by seven digits) is reserved for RODM use only. Do
                    not use this format for the names of objects that you create.</li>
                <li>Each object in a class must have a unique object name. </li>
                <li>v RODM supports a maximum of 2097135 objects.</li>

            </ul>
            <h4 class="heading">Object Name Characteristics with CHARACTER_VALIDATION(NO)</h4>
            <p class="a">When CHARACTER_VALIDATION(NO) is coded in EKGCUST, valid object names<br>
                have the following characteristics:</p>
            <ul class="a">
                <li>The name consists of 1 to 254 characters with an abstract data type of<br>
                    ObjectName that conforms to the PL/I syntax of CHAR(254) VARYING</li>
                <li>The first character cannot be the number sign (#) because it is reserved for<br>
                    MultiSystem Manager.</li>
                <li>Blank characters are not valid.</li>
                <li> Null characters are not valid.</li>
                <li>Both uppercase and lowercase alphabetic characters are permitted, and names<br>
                    are case-sensitive.</li>
                <li>The EKG_ prefix is reserved for RODM-created classes and objects. Do not use<br>
                    this prefix in the names of classes or objects that you create</li>
                <li>v EKG<i>xxxxxxx </i>(EKG followed by seven digits) is reserved for RODM use only. Do<br>
                    not use this format for the names of objects that you create.</li>
                <li>Each object in a class must have a unique object name.</li>
                <li>RODM supports a maximum of 2097135 objects.</li>
                </ul>



                <h3 class="heading1">Object Identifiers</h3>
                <p class="a">To minimize access time, RODM supports another approach to accessing an object.<br>
                    Any object in any class can be accessed in RODM based solely on the ObjectID of<br>
                    the object. RODM provides functions that convert the fully qualified "class<br>
                    name.object name" to an ObjectID, and convert the ObjectID to the fully qualified<br>
                    "class name.object name"</p>
                <p class="a">You can locate objects using any one of the specifications listed here, which are<br>
                    listed in decreasing order of search performance:
                    </p>
               <p class="a">1. ObjectID<br>
                2. ClassID plus ObjectName<br>
                3. ClassName plus ObjectName</p>
                <hr class="hr">
                <h2>RODM Fields</h2>
                <p class="a">All classes consist of fields that are either public or private, but not both. They<br>
                    must have a field name, and RODM assigns a field identifier. RODM supports a<br>
                    maximum of 4079 fields.</p>
                <p class="a">Fields within objects can contain information about the relationships among objects<br>
                    defined in RODM. You can determine these relationships by examining RODM<br>
                    classes and objects.</p>
                    <h3 class="heading1">Field Names</h3>
                <p class="a">Each RODM field has a character string name, called the <i>field name.</i> RODM<br>
                    system-defined field names are reserved by RODM and cannot be deleted by the<br>
                    user. See “System-Defined Fields” on page 207 for a list of the RODM<br>
                    system-defined fields.</p>
                <p class="a">The CHARACTER_VALIDATION keyword in EKGCUST specifies what degree of<br>
                    validity checking RODM performs for characters used in object names (see “Object<br>
                    Names” on page 205), class names (see “Class Names” on page 191), and field<br>
                    names.</p>
                <h4 class="heading">Field Name Characteristics with CHARACTER_VALIDATION(YES)</h4>
                <p class="a">When CHARACTER_VALIDATION(YES), which is the default, is coded in<br>
                    EKGCUST, valid field names have the following characteristics:</p>
                <ul class="b">
                    <li>v The name consists of 1 to 64 characters with a data type of ShortName that<br>
                        conforms to the PL/I syntax of CHAR(64) VARYING.</li>
                    <li>v The first character cannot be the number sign (#) because it is reserved for<br>
                        MultiSystem Manager.</li>
                    <li>Blank characters are not valid.</li>
                    <li>v Null characters are not valid. </li>
                    <li>v You can use both uppercase and lowercase alphabetic characters. Field names<br>
                        are case-sensitive, regardless of whether your application translates them into a<br>
                        single case.</li>
                </ul>
                <h3 class="heading1">Field Identifiers</h3>
                <p class="a">RODM assigns a 4-byte field identifier to each field. A field identifier is a symbolic<br>
                    representation of the name of a field. You can assign it and compare it to other<br>
                    field IDs. You can use a field ID instead of a field name to address the field<br>
                    through the user API. Using a field ID to address a field through the API is more<br>
                    efficient than using the field name. RODM includes the EKG_QueryFieldName<br>
                    function to convert a FieldID to a field name and the EKG_QueryFieldID function<br>
                    to convert a field name to a FieldID.</p>
                <p class="a">RODM-generated internal identifiers exist because they are faster to process than<br>
                    are character string names. These identifiers are always given preference over<br>
                    character string names in resolving which field is to be addressed.</p>
                <p class="a">For example, if both the Field_ID and the Field_name_length parameters are not<br>
                    null in a field access information block, the Field_ID is used, and the<br>
                    Field_name_ptr parameter is ignored. RODM does not check that a supplied<br>
                    Field_ID is consistent with a supplied field name. See Table 31 on page 317 for the<br>
                    format and parameters in a field access information block.</p>
                <p class="a">Field identifiers differentiate field names from each other without regard to the<br>
                    class or object where the field is located, a field identifier obtained for a field of<br>
                    one class or object can be reused for any field with the identical name regardless of<br>
                    the class or object. A field name does not contain any information about the class<br>
                    or object with which it is associated; however, the classes and objects include the<br>
                    information of what fields they contain.</p>
                    <h3 class="heading1">System-Defined Fields</h3>
                    <p class="a">System-defined fields are fields that are predefined by RODM and must exist for<br>
                        every class and object. These fields and their values are never inherited; RODM<br>
                        creates the fields and sets their values when it creates or changes the object or class<br>
                        to which they belong. Application programs and methods cannot change the<br>
                        contents of these fields through the user API or the method API.</p>
                    <p class="a">The names of the system-defined fields are reserved names in RODM. You cannot<br>
                        define other fields in classes using these same names.</p>
                    <p class="a">Of the system-defined fields, only the MyClassChildren, MyObjectChildren and<br>
                        WhatIAm fields change during RODM execution. Therefore, these are the only<br>
                        system-defined fields for which a notify subfield can be created.</p>
                    <p class="a"><b class="bold">Note:</b> Notification methods assigned to these fields to detect deletions of class or<br>
                        object children cannot access the deleted class or object. RODM executes the<br>
                        notification method after it completes the delete process.</p>
                    <p class="a">Every RODM class and object contains the following system-defined fields:</p>
                    <h4 class="heading">MyPrimaryParentID</h4>
                    <p class="b">The class ID of the parent class in the primary hierarchy. For objects, this<br>
                        field contains the class ID of the class of the object. For classes (other than<br>
                        the universal-class), this field contains the class ID of the parent class in<br>
                        the primary hierarchy. The universal-class is the only class that has no<br>
                        parent, and therefore, a null MyPrimaryParentID field.</p>
                    <p class="b">The data type of this field is ClassID.</p>
                    <h4 class="heading">MyPrimaryParentName</h4>
                    <p class="b">The name of the parent class in the primary hierarchy.</p>
                    <p class="b">The data type of this field is ShortName.</p>
                    <h4 class="heading">MyID</h4>
                    <p class="b">The ID of the object or class upon which the field resides. For objects, the<br>
                        contents of MyID is the object ID. For classes, the contents of MyID is the<br>
                        class ID</p>
                    <p class="b">The data type of this field is ObjectID for objects and ClassID for classes</p>
                    <h4 class="heading">MyName </h4>
                    <p class="b">The full name of the current object or class. For objects, this field contains<br>
                        the object name. For classes, this field contains the class name.</p>
                    <p class="b">The data type of this field is ObjectName for objects and ShortName for<br>
                        classes.</p>
                        <h4 class="heading">WhatIAm </h4>
                        <p class="b">The object or class type</p>
                        <p class="b">The data type for this field is Integer and has the following values:</p>
                        <p class="b">1 An object<br>
                            2 A class with no children<br>
                            3 A class with object children<br>
                            4 A class with class children<br>
                            5 A class with both class children and object children</p>
                    <p class="a">Every RODM class contains the following additional system-defined fields: </p>
                    <h4 class="heading">MyClassChildren</h4>
                    <p class="b">A list of class IDs of the class children of this class. Each entry in the list is<br>
                        the class ID of one child class.</p>
                    <p class="b">The data type of this field is ClassIDList. </p>
                    <p class="b">When a class is created, the value of this field is set to null. Thereafter,<br>
                         entries are added, set, and deleted from this list by the creation and<br>
                        deletion of classes that are specified at creation as having this class as<br>
                        primary parent.</p>
                  <h4 class="heading">MyObjectChildren</h4>
                  <p class="b">A list of object IDs of the object children of this class. Each entry in the list<br>
                    is the object ID of one child object.</p>
                    <p class="b">Data type is ObjectIDList.</p>
                    <p class="b">When a class is created, the value of this field is set to null. Thereafter,<br>
                         entries are added, set, and deleted from this list by the creation and<br>
                        deletion of objects that are specified at creation as having this class as<br>
                        primary parent.</p>
                    <p class="a">The MyClassChildren and MyObjectChildren fields are never created for objects.</p>
                    <hr class="hr">
                    <h2>RODM Subfields</h2>
                    <p class="a">The RODM data types, defined in “Abstract Data Type Reference” on page 219,<br>
                        restrict the values that RODM considers valid for a field. But network management<br>
                        applications require more information about a field than just its value. A field must<br>
                        contain several pieces of data or logic to be useful in a data cache that stores both<br>
                        persistent and volatile information.<br>
                        </p>
                    <p class="a">When a field is created, RODM automatically creates a value subfield for the field.<br>
                        If no other subfields are explicitly defined for the field, any reference to the field is<br>
                        the same as a reference to the value subfield of the field.</p>
                    <p class="a">Suppose that the dominant value to be preserved in the<br>
                        <i>number_of_waiting_print_jobs</i> field of a printer object is the number of print jobs<br>
                        waiting to be printed. This value is volatile and the contents of this field are of<br>
                        little use if the value is several hours old. Suppose also that you can save the<br>
                        number of jobs waiting to be printed and also the time at which the value was<br>
                        obtained. You can now use this timestamp to invalidate the data that is old and<br>
                        indicate that current data is required.</p>
                    <p class="a">A time stamp alone does not solve the problem. When an application requests the<br>
                        contents of the <i>number_of_waiting_print_jobs field,</i> there must be some logic in place<br>
                        to compare the contents of the timestamp with the current time and take an<br>
                        appropriate action based on the age of the data in the field. The design of RODM<br>
                        permits a field to be composed of several subfields. These subfields can refer to<br>
                        methods that can be set to automatically do such things as check time stamps<br>
                        before responding to a query</p>
                    <p class="a">There is a fixed list of subfields that can appear in a field. All subfields are<br>
                        optional except for the value subfield, which contains the data stored in the field<br>
                        and so must exist if the field exists. The following list contains each kind of<br>
                        subfield and its intended use.</p>
                    <p class="a">The value and prev_val subfields have the same data type as the corresponding<br>
                        field. All other subfields have predetermined data types that are set based on the<br>
                        kind of subfield. The data type of each subfield is specified in the following list<br>
                        along with a description of each subfield. When a subfield is created, RODM<br>
                        assigns it a null value based on the subfield data type requirements.</p>
                    <p class="a">RODM defines the following subfields:</p>
                    <h3 class="heading1">Value (Required)</h3>
                    <p class="b">The actual data associated with the field. The value is defined in terms of<br>
                        RODM abstract data types, such as Integer, CharVar, or Floating.</p>
                     <p class="b">The data type must be one of those defined in “Abstract Data Type Reference”<br>
                        on page 219 and is identical to the data type of the field. The value subfield is<br>
                        the only system-defined subfield of a field. All other subfields are optional<br>
                        with their presence obtained by a transaction against the field of the class<br>
                        through the user API.</p>
                        <h3 class="heading1">Query</h3>
                        <p class="a">A method specification (data type MethodSpec) for a query method</p>
                        <p class="a"><ul><li>Querying a field invokes a query method if this subfield has a value.</li></ul></p>
                        <p class="a"><ul><li>v A query method can modify the queried data from a field.</li></ul></p>
                        <p class="a">The query subfield contains a method that is invoked before the field contents<br>
                            are returned to a caller in response to a query of the field. If a query method is<br>
                            defined, the query method is responsible for returning a value in response to<br>
                            the query. If a query method does not return a value in response to the query, RODM returns one.</p>
                        <p class="a">The data type of a query subfield is MethodSpec. The MethodSpec type<br>
                            includes the object identifier of the method to be invoked, plus a list of<br>
                            parameters to be passed to the method.</p>
                        <p class="a">The parameters indicate fields of the object that the user has set up to be used<br>
                            by the method. The parameters in those fields are most frequently set when<br>
                            the method is installed in the subfield. However, some or all of those<br>
                            parameters can be set by assigning values to the corresponding fields<br>
                            immediately before the query transaction that triggers the query method is<br>
                            requested.</p>
                            <h3 class="heading">Change</h3>
                        <p class="b">A method specification for a change method.</p>
                        <p class="b"><ul><li>A change field request invokes a change method if this subfield has a value</li></ul></p>
                        <p class="b"><ul><li>A change method modifies the data in the field on which it is defined.</li></ul></p>
                        <p class="b">The change subfield is a method that is invoked to change the contents of a<br>
                            field as requested by an EKG_ChangeField or EKG_ChangeMultipleFields<br>
                            function request, either from a user outside of RODM, or by another method.<br>
                            If a field receives a change request and has a change subfield, the change<br>
                            method must make the change to the value of field; RODM does not change<br>
                            the value of a field that has a change subfield defined.</p>
                        <p class="b">The data type of a change subfield is MethodSpec. The subfield includes the ID<br>
                            of a method and the locations in fields of the object where parameters for the<br>
                            method are to be found.</p>
                        <p class="b">The change subfield cannot exist for any system-defined field, such as<br>
                            MyName, MyID, MyPrimaryParentID, MyPrimaryParentName, WhatIAm,<br>
                            MyClassChildren, and MyObjectChildren.</p>
                            <h3 class="heading">Notify</h3>
                        <p class="b">A method specification for one or a list of notification methods.</p>
                        <p class="b"><ul><li>v Changing a field invokes a notification method if this subfield has value.<br>
                            RODM invokes the notification method after the change in the field is<br>
                            complete</li></ul></p>
                        <p class="b"><ul><li>A notify method can notify subscribed users of changes to fields.</li></ul></p>
                        <p class="b">The notify subfield contains a list of methods and associated parameters. Each<br>
                            method in the list is invoked one at a time after every change in the value of<br>
                            the field as requested by a change request from a user. Methods in the list are<br>
                            intended to notify other objects or to notify RODM users when changes in<br>
                            state take place. The data type of each entry in the list is SubscriptSpec.<br>
                            </p>
                        <p class="b">The data type of the subfield is SubscriptSpecList. A method name, parameters<br>
                            for the method from object fields, and a description of who is to be notified are<br>
                            included in each entry. When the method is invoked, the logic in the method<br>
                            decides, based on the data in the object, whether to notify anyone. The method<br>
                            can notify the original subscriber or it can be programmed to notify another<br>
                            application or to submit transactions to other RODM objects. Notification<br>
                            methods can submit transactions, other than the EKG_QueryObjectName<br>
                            function, to other RODM objects only through the<br>
                            EKG_MessageTriggeredAction method API function</p>
                            <h3 class="heading">Timestamp</h3>
                        <p class="b">The time at which the value subfield of the field was last changed. RODM<br>
                            manages this subfield. This subfield is read-only. The data type of the subfield<br>
                            is TimeStamp.</p>
                        <p class="b">The timestamp subfield is created and deleted using the EKG_CreateSubfield<br>
                            and EKG_DeleteSubfield functions. When it is defined, RODM updates the<br>
                            timestamp subfield for every successful change transaction against the field,<br>
                            including when the new value is the same as the old value. The timestamp<br>
                            subfield is always associated with the value subfield of the same field. A<br>
                            change transaction against the value subfield, rather than against the field,<br>
                            does not cause the timestamp subfield to be updated. If you issue the<br>
                            EKG_RevertToInherited function and the field contains a local value and<br>
                            corresponding time-stamp, the time-stamp subfield is also reverted to its<br>
                            inherited value</p>
                            <h3 class="heading">Prev_val</h3>
                        <p class="b">A copy of the previous contents of the value subfield. RODM manages this<br>
                            subfield. This subfield is read-only. The data type of this subfield is the same<br>
                            as the data type of the value subfield. You cannot create a prev_val subfield for<br>
                            system-defined fields. See “Data Types for Subfields” for a list of abstract data<br>
                            types that the prev_val field can contain.</p>
                        <p class="b">The prev_val subfield is created and deleted using the EKG_CreateSubfield<br>
                            and EKG_DeleteSubfield functions. When it is defined, RODM updates the<br>
                            prev_val subfield for every successful change transaction against the field,<br>
                            including when the new value is the same as the old value. The prev_val<br>
                            subfield is always associated with the value subfield of the same field. A<br>
                            change transaction against the value subfield, rather than against the field,<br>
                            does not cause the prev_val subfield to be updated. If you issue the<br>
                            EKG_RevertToInherited function and the field contains a local value and<br>
                            corresponding prev_val, the prev_val subfield is also reverted to its inherited<br>
                            value.</p>
                            <h3 class="heading1">Prev_val</h3>
                        <p class="a">Certain RODM abstract data types can be used for each subfield. The abstract data<br>
                            types are defined in “Abstract Data Type Reference” on page 219.</p>
                            <h4 class="heading">Subfield</h4>
                            <p class="b"><h4 class="heading">Valid Abstract Data Types</h4></p>
                            <h4 class="heading">Value</h4>
                            <p class="b">
                                <ul><li>AnonymousVar<br></li>
                                <li>BERVar<br></li>
                                    <li>CharVar<br></li>
                                        <li>FieldID<br></li>
                                            <li>Floating<br></li>
                                                <li>GraphicVar<br></li>
                                                    <li>IndexList v Integer<br></li>
                                                        <li>MethodSpec<br></li>
                                                            <li>ObjectLink<br></li>
                                                                <li>ObjectLinkList v SelfDefining<br></li>
                                                                    <li>Smallint v TimeStamp<br></li></ul>
                            </p>
                            <h4 class="heading">Query</h4>
                            <p class="b"><ul><li>MethodSpec</li></ul></p>
                            <h4 class="heading">Change</h4>
                            <p class="b"><ul><li>MethodSpec</li></ul></p>
                            <h4 class="heading">Notify</h4>
                            <p class="b"><ul><li> SubscriptSpecList</li></ul></p>
                            <h4 class="heading">Time Stamp</h4>
                            <p class="b"><ul><li> Time Stamp</li></ul></p>
                            <h4 class="heading">Prev_val</h4>
                            <p class="b">
                                <ul><li> AnonymousVar<br>
                                    <li> BERVar<br>
                                    <li>CharVar<br></li>
                                        <li>FieldID<br></li>
                                            <li> Floating<br></li>
                                                <li>GraphicVar<br></li>
                                                    <li>IndexList v Integer<br></li>
                                                        <li>MethodSpec<br></li>
                                                            <li>SelfDefining<br></li>
                                                                <li>Smallint v TimeStamp</li></ul>
                            </p>
                            <hr class="hr">
                            <h2>Multivalued Fields and Links between Objects</h2>
                            <p class="a">RODM permits the use of multivalued fields to establish the relationships between<br>
                                objects. Multivalued fields support the creation of one-to-one, one-to-many,<br>
                                 many-to-one, and many-to-many relationships between objects</p>
                             <p class="a"><b class="bold">Note:</b> The links described in this section are RODM-defined relational links. These<br>
                                 links are defined between two objects in the RODM data cache and must not be<br>
                                 confused with physical links, such as network links, which are represented by<br>
                                 GMFHS-defined link objects</p>
                            <p class="a">The EKG_LinkNoTrigger and EKG_LinkTrigger functions enable user applications<br>
                                and methods to create links between two objects. The EKG_UnlinkNoTrigger and<br>
                                EKG_UnlinkTrigger functions enable user applications and methods to delete links<br>
                                between two objects. Use an ObjectLink type field to link to one object. Use an<br>
                                ObjectLinkList type field to link to one or more objects. An ObjectLink field of one<br>
                                object always links to an ObjectLink or ObjectLinkList field of another object. An<br>
                                ObjectLinkList field of one object always links to ObjectLink or ObjectLinkList<br>
                                fields of other objects.</p>
                            <p class="a">The reserved data types ObjectID and ObjectIDList are used by RODM for links<br>
                                between system-defined fields. These system-defined fields, such as the<br>
                                MyObjectChildren field, are managed by RODM and cannot be changed directly<br>
                                by user applications or methods.</p>
                            <p class="a">Figure 38 shows single-value links using fields of data type ObjectLink and a<br>
                                multivalue link using a field of data type ObjectLinkList</p>
                                <img src="onehundred.PNG">
                                <p class="a"><i>Figure 38. Examples of Links between Objects in RODM</i></p>
                                <p class="a">Figure 38 contains three RODM objects. Two of the objects represent host<br>
                                    processors in a network, and the third object is a resource type object which is<br>
                                    used to identify types of objects. Each of the two host objects, NETA.A01MPU and<br>
                                    NETV.B01MPU, has a single-value link to the resource type object. The resource<br>
                                    type object, DUIXC_RTS_HOST, has a multivalue link to each of the two host<br>
                                    objects.</p>
                                <p class="a">The object NETA.A01MPU has a field named DisplayResourceType, which is data<br>
                                    type ObjectLink. The DisplayResourceType field contains the ObjectID (▌I▐) of the<br>
                                    object being linked to (▌J▐), and the FieldID (▌L▐) of the field being linked to (▌M▐).</p>
                                <p class="a">The object NETB.B01MPU also has a field named DisplayResourceType linked to<br>
                                    the field Resource of object DUIXC_RTS_HOST. DisplayResourceType contains the<br>
                                    ObjectID (▌K▐) of DUIXC_RTS_HOST (▌J▐) and the FieldID (▌N▐) of Resources<br>
                                    (▌M▐).</p>
                                <p class="a">The object DUIXC_RTS_HOST has the field Resources that is linked to both of the<br>
                                    host objects. The ObjectLinkList field Resources contains the number of objects it is<br>
                                    linked to (▌O▐). The first list element of Resources contains the ObjectID (▌A▐) of<br>
                                    object NETA.A01MPU (▌B▐) and the FieldID (▌C▐) of field DisplayResourceType<br>
                                    (▌D▐). The second list element of Resources contains the ObjectID (▌E▐) of object<br>
                                    NETB.B01MPU (▌F▐) and the FieldID (▌G▐) of field DisplayResourceType (▌H▐).
                                    </p>
                                <p class="a">When you create links using the EKG_LinkNoTrigger or EKG_LinkTrigger<br>
                                    functions, you specify the pair of objects and fields to be linked, and RODM fills in<br>
                                    the ObjectID and FieldID values in both objects. Both objects must exist in RODM<br>
                                    before they can be linked.</p>
                                <h3 class="heading1">Link and Unlink Action Functions</h3>

                                <p class="a">The link and unlink action functions can be invoked by users through the method<br>
API and user API. The EKG_LinkNoTrigger function and the EKG_LinkTrigger<br>
function are used to establish a link between two fields on two objects. The<br>
EKG_UnlinkNoTrigger function and the EKG_UnlinkTrigger function delete a link<br>
between two objects. Each of these functions require two objects and two fields<br>
specified through the Entity_access_info_ptr and Field_access_info_ptr parameters.<br>
The fields must be of data type ObjectLinkList or ObjectLink. See<br>
“EKG_LinkNoTrigger, EKG_LinkTrigger - Link Two Objects” on page 407 and<br>
“EKG_UnlinkNoTrigger, EKG_UnlinkTrigger - Unlink Two Objects” on page 448<br>
for function block formats and additional details.</p>
                                 <p class="a">Fields that are lists or of type ObjectLink are changed only by link and unlink<br>
                                    actions. For these actions, there are always two fields involved, one at each end of<br>
                                    the link. Change methods can be defined to these fields. These change methods are<br>
                                    triggered by the EKG_LinkTrigger or EKG_UnlinkTrigger functions. The change<br>
                                    methods must set a return code with EKG_SetReturnCode to indicate whether the<br>
                                    link or unlink can proceed.</p>
                                <p class="a"><ul><li> A nonzero return code prevents the link or unlink.</li></ul></p>
                                <p class="a"><ul><li>v If no change method exists on one (or both) of the fields, RODM assumes the<br>
                                    return code is zero and the link or unlink proceeds.</li></ul></p>
                                <p class="a"><ul><li>If a change method exists, but it does not set the return code explicitly, RODM<br>
                                    assumes the return code is zero and the link or unlink proceeds.
                                </li></ul></p>
                                <p class="a">The change methods are triggered in the order in which the fields appear in the<br>
                                    function block.</p>
                                <p class="a">To be symmetric, the RODM program invokes the appropriate notify methods at<br>
                                    both ends of a link when a link or unlink action is requested and the subfields<br>
                                    exist at both ends of the link. If two methods are invoked, the one invoked first is<br>
                                    the top field specified in the function block that specifies the desired action. For<br>
                                    notify methods, first one list is processed, then the other list is processed. If the<br>
                                    link or unlink is prevented by the nonzero return code, the notify methods are not<br>
                                    triggered.</p>
                                <p class="a">Link and unlink action functions are applicable only in linking two objects<br>
                                    together. It is not possible, using the link action function, to link a class to another<br>
                                    class or object. An object inherits the existence of fields of type ObjectLink from its<br>
                                    class, but an object can only inherit the null value from its class for these fields.<br>
                                    Likewise, in the hierarchy of classes, the existence of fields of type ObjectLink is<br>
                                    inherited by children classes, but values in all such fields are null.</p>
                                <p class="a">If the type of a field to be linked is ObjectLinkList, the link action creates a new<br>
                                    entry in the list and sets that entry to contain the ObjectID and FieldID of the other<br>
                                    object-field pair. Links constructed for fields of data type ObjectLinkList are not<br>
                                    guaranteed to be ordered within the field according to any particular algorithm<br>
                                    like FIFO or LIFO. If the type is a simple ObjectLink, the value of that field is set<br>
                                    to contain the ObjectID and FieldID of the other object-field pair. Because the link<br>
                                    applies to each object-field pair, it establishes a two-way link between the two<br>
                                    objects. Unlink removes such links. Link and unlink actions are the only actions<br>
                                    available to RODM users that change fields of type ObjectLink.</p>
                                <p class="a">If a field is a single ObjectLink, a query of that field yields a response of type<br>
                                    ObjectLink, which is an 8-byte ObjectID followed immediately by a 4-byte FieldID<br>
                                    for a total of twelve bytes. If a field is an ObjectLinkList, a query of the field<br>
                                    through either the user API or method API causes an array of ObjectLink entries to<br>
                                    be returned to the user. In other words, each element in the array is a 12-byte pair<br>
                                    of ObjectID and FieldID. RODM users cannot query the entries of an<br>
                                    ObjectLinkList, individually.</p>
                                <p class="a">The same principle applies to queries of a MyObjectChildren field. A query of such<br>
                                    a field yields an array where each element in the array is of data type ObjectID for<br>
                                    MyObjectChildren field. The length of the array is identical to the length of the list<br>
                                    in the queried field.</p>
                                <p class="a">Links between objects established with the link action function are used to<br>
                                    represent both peer-to-peer relationships and to represent secondary parent-child<br>
                                    relationships. Primary parent-child relationships are required and are embodied in<br>
                                    the system-defined fields MyClassChildren, and MyObjectChildren of objects and<br>
                                    classes.</p>
                                    <h3 class="heading1">Subfields Associated with Fields</h3>
                                    <p class="a">You cannot create a query subfield for fields that are of data types ObjectLink or<br>
                                        ObjectLinkList. For fields that are not of data types ObjectLink or ObjectLinkList,<br>
                                        the value subfield is the single field entry and can be queried and manipulated<br>
                                        without triggering methods. For fields that are of data types ObjectLink or<br>
                                        ObjectLinkList, the value subfield consists of an entire list of entries, and the value<br>
                                        subfield can only be queried without triggering a query method.</p>
                                    <p class="a">Change transactions are not applicable to fields of data types ObjectLink or<br>
                                        ObjectLinkList, and similarly, change transactions are not applicable to the value<br>
                                        subfield of a field that is of data types ObjectLink or ObjectLinkList. Only link and<br>
                                        unlink functions exist for changing the values in fields of type ObjectLinkList, and<br>
                                        only creation and deletion of children changes a MyObjectChildren field.</p>
                                    <p class="a">To perform the link and unlink action functions, without triggering notify methods,<br>
                                        the RODM program supports the EKG_LinkNoTrigger function and the<br>
                                        EKG_UnlinkNoTrigger function.</p>
                                    <p class="a">The subfields possible for fields that are of type ObjectLink are query, notify, and<br>
                                        timestamp subfields. For fields of type ObjectLink and ObjectLinkList, change<br>
                                        subfields are enabled. However, the RODM program supports only one subfield<br>
                                        for the entire list; separate subfields are not supported for each entry in the list.<br>
                                        </p>
                                    <p class="a">Any change to any entry of the list is considered a change to the entire list.<br>
                                        Therefore, if there is a notify list, any change to any entry in the list of links (the<br>
                                        field) results in all the methods in the notify list being invoked.</p>
                                    <p class="a">If a child object inherits the existence of a field that is of data types ObjectLink or<br>
                                        ObjectLinkList, the child object also sees the field as a data type ObjectLink or<br>
                                        ObjectLinkList field. But the RODM program does not support the inheritance of<br>
                                        values in fields of data types ObjectLink or ObjectLinkList. The entries in fields of<br>
                                        data types ObjectLink or ObjectLinkList are independent of the entries in any other<br>
                                        fields of data types ObjectLink or ObjectLinkList. They are created one at a time by<br>
                                        the EKG_LinkNoTrigger function or the EKG_CreateObject function, and they are<br>
                                        deleted one at a time by the EKG_UnlinkNoTrigger function or the<br>
                                        EKG_DeleteObject function.</p>
                                    <hr class="hr">
                                    <h2>Indexed Fields</h2>
                                    <p class="a">The EKG_Locate function retrieves a list of Object IDs of objects having a specified<br>
                                        value in a specified field. This function makes it easier for an application to<br>
                                        retrieve the list of Object IDs. Rather than scanning the user's entire data model<br>
                                        using the query field functions (looking for the specified field and value), the<br>
                                        application invokes the EKG_Locate function with the desired field and field value.</p>
                                    <p class="a">For a field to be located by the EKG_Locate function, that field must have been<br>
                                        created as a public_indexed field. For public_indexed fields, RODM maintains<br>
                                        tables of Object IDs by field name and field value. Because additional processing is<br>
                                        required to maintain these tables, users must create public_indexed fields only for<br>
                                        fields that exploit the EKG_Locate function. An example of this is a data model<br>
                                        with Employees as a class, each employee name as an object under that class, and<br>
                                        EmployeePhoneNumber as an indexed field. In this example, an application can<br>
                                        locate all of the objects that have a specified phone number in field<br>
                                        EmployeePhoneNumber without performing a query on every object in the data<br>
                                        model.
                                        </p>
                                    <p class="a">Indexed Fields can be of CharVar or IndexList data type. IndexList fields generate<br>
                                        multiple ObjectID table entries - one for each value in the list. For both CharVar<br>
                                        and IndexList, EKG_Locate accepts one character string (maximum length 254<br>
                                        bytes) for comparison, pointed to by Indexed_data_ptr.</p>
                                    <p class="a">See “Indexed Fields” on page 488 for performance-related information about<br>
                                        defining public_indexed fields.</p>
                                    <hr class="hr">
                                    <h2>Object and Class Locking in RODM</h2>

                                    <p class="a">RODM now controls locking automatically. The following functions are no longer<br>
necessary, but remain available for compatibility with existing applications.</p>
<p class="a"><ul><li>EKG_LockObjectList function</li></ul></p>
<p class="a"><ul><li>EKG_UnlockAll function</li></ul></p>
<p class="a">No changes to existing applications that use these functions are required.</p>
<hr class="hr">
<h2>Using the Application Program Interfaces</h2>
<p class="a">This section briefly explains the two RODM application program interfaces</p>
<h3 class="heading1">User Application Program Interface (API)</h3>
<p class="a">A RODM user application is an external program that accesses RODM data<br>
    through the user API to perform a task. This RODM user application can be coded<br>
    in any language that enables you to meet the parameter passing conventions of<br>
    RODM. However, RODM supplies control block structures only for PL/I and C.</p>
    <p class="a">Figure 39 illustrates how user applications access RODM data in a z/OS<br>
        environment using EKGUAPI, the user API module. The steps for coding a full<br>
        RODM application are described in Chapter 11, “Writing Applications that Use<br>
        RODM,” on page 305.
        </p>
    <img src="twohundred.png">
    <p class="a"><i>Figure 39. RODM System Structure (z/OS)</i></p>
    <h3 class="heading1">Method Application Program Interface (API)</h3>
    <p class="a"><i>Methods</i> are small executable programs that reside in the RODM address space.<br>
        Methods can be invoked by user applications, by changes to fields in RODM, by<br>
        other methods, and at RODM initialization.
        </p>
    <p class="a">The NetView program supplies several general-purpose methods that might meet<br>
        your needs; if not, you can write your own using PL/I or C.</p>
    <p class="a">Figure 39 illustrates how methods access RODM data in a z/OS environment using<br>
        EKGMAPI, the method API module. The steps and information associated with<br>
        coding a RODM method are described in Chapter 13, “Writing RODM Methods,”<br>
        on page 343.
        </p>
        <hr class="hr">
        <h2>RODM Abstract Data Types</h2>
    <p class="a">This section describes how to use the RODM data types. Different data types can<br>
        be used in different contexts, such as the types of data in fields, subfields, fields of<br>
        the user API or method API, or parameters passed to methods.</p>
    <p class="a">Several of the RODM data types are compound data types; they correspond to<br>
        structures in programming languages. PL/I macro declarations and C typedef<br>
        statements are provided for these compound data types. Ensure that there is no<br>
        compiler-generated padding when you map these declarations to storage. You can<br>
        do this in PL/I by adding the UNALIGNED attribute to each declaration, and, in<br>
        C, by using the _Packed qualifier.</p>
        <h3 class="heading1">Null Values of Data Type</h3>
        <p class="a">The RODM program specifies a null value for each data type. Typically, you use<br>
            null values for:</p>
        <p class="a"><ul><li>Locator types</li></ul></p>
        <p class="a"><ul><li>Locator types are data that locates or points to other data. A null value means<br>
            that the data is <i>pointing to nothing.</i></li></ul></p>
        <p class="a"><ul><li>Types that contain non-locator information</li></ul></p>
        <p class="a"><ul><li>For types that contain non-locator information, such as numbers, counts, or<br>
            flags, the null value always implies <i>no information here</i> or<i> not yet set to a value.</i></li></ul></p>
        <p class="a">The RODM program sets the value of a field or a subfield to the null value for the<br>
            type of field or subfield whenever it first creates it on a class. When a class or<br>
            object inherits a field from its parent class, the value of the field is set to the value<br>
            on the parent class.</p>
        <p class="a">See “Abstract Data Type Reference” on page 219 for a specification of the null<br>
            value for each data type</p>
            <h3 class="heading1">Data Type Identifiers</h3>
            <p class="a">When user applications pass data to the RODM program, the RODM program<br>
                usually requires that they also pass the data type of the data along with the data.<br>
                When the RODM program passes data to an application, the RODM program<br>
                usually includes the data type of the data along with the data. To efficiently<br>
                identify data types, there is a decimal data type identifier for each RODM data<br>
                type.</p>
            <p class="a">To find the data type identifier for a particular data type, see “Abstract Data Type<br>
                Reference” on page 219.</p>
                <h3 class="heading1">Types of Data in Fields</h3>   
            <p class="a">Your application programs and methods must assign a data type to each field in a<br>
                class when they issue an API call to create a field. After the API has created the<br>
                field, you cannot change the data type during the life of the field.</p>
            <p class="a">List abstract data types are specified for fields that are to contain lists of<br>
                information instead of a single value. The list data type is available to form lists of<br>
                type IndexList, ObjectLink, ObjectID, and ClassID. This field type enables the<br>
                specification of multiple-to-single relationships and multiple-to-multiple<br>
                relationships of classes and objects.</p>
            <p class="a">Some data types that can be specified for fields are restricted, depending on the<br>
                nature of the field. The RODM program limits the possible relationships of objects<br>
                and classes in order to assure that incorrect identifiers are not left in RODM after<br>
                an object or a class is deleted. For example, the following conceptually feasible<br>
                relationships are prohibited by RODM:</p>
            <p class="a"><ul><li>v Relationships between an object and classes other than the parent child<br>
                relationships in the primary hierarchy. Class relationships must be inheritance<br>
                relationships</li></ul></p>
            <p class="a"><ul><li>v Relationships between two objects other than those that are represented by<br>
                ObjectLinks, using the EKG_LinkNoTrigger and EKG_LinkTrigger functions</li></ul></p>
                <h3 class="heading1">Abstract Data Type Reference</h3>
                <p class="a">This section describes the abstract data types defined by the RODM program.<br>
                    Include the macro EKG1IADT for PL/I or EKG3CADT for C in your user<br>
                    applications and methods. Including this macro enables you to declare the<br>
                    variables in your programs to be the data types needed to use RODM functions.</p>
                <p class="a">For example, if you need to specify the name of a method in a RODM function<br>
                    block, the parameter you pass must be declared as the MethodName abstract data<br>
                    type. To declare a variable named ThisMethodName in PL/I, use the statements:</p>
                <p class="a">&nbsp;&nbsp;&nbsp;&nbsp;%include EKGLIB(ekg1iadt);&nbsp;&nbsp;&nbsp;&nbsp; /* Abstract data declaration */<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;DCL ThisMethodName MethodName;&nbsp;&nbsp;&nbsp;&nbsp; /* 8-byte char */</p>
                <p class="a">To declare the same variable in C, use the statements:</p>
                <p class="a">&nbsp;&nbsp;&nbsp;&nbsp; #include "ekg3cadt.h" &nbsp;&nbsp;&nbsp;&nbsp; /* Abstract data declaration */<br>
                    &nbsp;&nbsp;&nbsp;&nbsp; MethodName ThisMethodName;&nbsp;&nbsp;&nbsp;&nbsp;  /* 8-byte char */</p>
                <p class="a">Examples of declaring variables of each type are provided in the file EKG5VDCL<br>
                    for PL/I and in the file EKG6VDCL for C.</p>
                <p class="a">In the data type definitions that follow, some of the data types are specified as<br>
                    being reserved. You cannot specify these data types when you create a field<br>
                    definition; these data types are reserved for fields created by the RODM program</p>
                <h4 class="heading">Anonymous(N) (Reserved)<br>
                    Data Type Identifier</h4>
                <p class="a">29</p>
                <h4 class="heading">Description</h4>
                <p class="a">A variable length sequence of data bytes in which only the creator of the data<br>
                    knows the value of the data contents. The maximum length of the string is 254<br>
                    bytes. The actual length is implicit and based on where a variable of this type has<br>
                    been defined for use. The format of the variable contents is unknown at the user<br>
                    API level. Only the application program or method that is using RODM and that<br>
                    set the value understands this type. This abstract data type cannot be used in a<br>
                    SelfDefining data string.</p>
                    <h4 class="heading">Null Value</h4>
                    <p class="a">Unknown</p>
                    <h4 class="heading">PL/I Declaration</h4>
                    <p class="a">% Anonymous = ’CHAR’;</p>
                    <h4 class="heading">C Declaration</h4>
                    <p class="a">typedef char Anonymous;</p>
                    <h4 class="heading">AnonymousVar<br>
                        Data Type Identifier</h4>
                        <p class="a">30</p>
                        <h4 class="heading">Description</h4>
                        <br>
                        <p class="a">A variable length string of data that consists of up through 32767 bytes.<br>
                            Constructed as a 2-byte length field followed by the number of data bytes specified<br>
                            by the length field. This data string can be binary data bytes of any value.</p>
                        <p class="a">The format of the variable contents is unknown at the user API level. Only the<br>
                            application program or method that set the value can understand the format.</p>
                            <h4 class="heading">Null Value</h4><br>
                            <p class="a">Length field is zero.</p>
                            <h4 class="heading">PL/I Declaration</h4>
                            <p class="a">% AnonymousVar = ’CHAR(32767) VARYING’;</p>
                            <h4 class="heading">C Declaration</h4>
                            <p class="a">typedef &nbsp;&nbsp;&nbsp;&nbsp;_Packed struct {<br>
                                &nbsp;&nbsp;&nbsp;&nbsp;Smallint Length;<br>
                                &nbsp;&nbsp;&nbsp;&nbsp; Anonymous Text[1];<br>
                                &nbsp;&nbsp;&nbsp;&nbsp;} AnonymousVar;</p><br>
                                <h4 class="heading">ApplicationID (Reserved)<br>
                                    Data Type Identifier</h4>
                                <p class="a">3</p>
                                <h4 class="heading">Description</h4><br>

                                <p class="a">An 8-byte token containing the user application name. This application ID is<br>
verified by your system authorization facility. Characters are positioned<br>
left-justified within the 8 bytes and padded with blanks on the right. The host<br>
system code page defines the blank; for z/OS, the assumed code page is code page<br>
00500, on which a blank is X'40'.</p>
<h4 class="heading">Null Value</h4><br>
<p class="a">All bytes are blank (for code page 00500, X'40').</p>
<h4 class="heading">PL/I Declaration</h4><br>
<p class="a">% ApplicationID = ’CHAR(8)’;</p>
<h4 class="heading">C Declaration</h4>
<p class="a">typedef &nbsp;&nbsp;&nbsp;&nbsp; _Packed struct {<br>
    &nbsp;&nbsp;&nbsp;&nbsp;char Data_char[8];<br>
    &nbsp;&nbsp;&nbsp;&nbsp;} ApplicationID;</p>
    <h4 class="heading">BERVar<br>
        Data Type Identifier</h4>
        <p class="a">31</p>
        <h4 class="heading">Description</h4><br>
        <p class="a">The BERVar data type specifies BER data to the RODM load function. RODM<br>
            verifies part of the BER data format but does not interpret any of it. The following<br>
            description identifies the information verified by RODM.</p>
        <p class="a">The maximum length of the BER data type (including the identifier, length and<br>
            contents bytes) must not exceed 32767. Figure 40 shows the format of BER data.</p>
        <img src="threehundred.PNG">
        <p class="a"><i>Figure 40. Format of BER Data</i></p>
        <p class="a">RODM verifies the following BER data:</p>
        <p class="a"><ul><li>Identifier bytes. Identifier bytes can take two forms, short or long. The form is<br>
            determined by the tag number (bits 5 to 1) in the first byte.</li></ul></p>
        <p class="a">– If the tag number is less than or equal to 30 ('11110'b), the identifier byte is in<br>
            the short form and only a single identifier byte is needed.</p>
        <img src="fourhundred.PNG">
        <p class="a"><i>Figure 41. Identifier Byte in Short Form</i></p>
        <p class="a">– If the tag number in the first byte is equal to 31 ('11111'b), the identifier byte<br>
            is long. For the long form, more than one identifier byte exists. In each byte<br>
            following the leading byte, bit 8 is set to 1 until the last identifier byte. In the<br>
            last identifier byte bit 8 is set to 0 (zero).<br>
            Figure 42 on page 222 shows the long form with three identifier bytes.</p>
        <img src="fivehundred.PNG">
        <p class="a"><i>Figure 42. Identifier Byte in Long Form</i></p>
        <p class="a"><ul><li> Length bytes.</ul</li> The length byte specifies the length of the contents bytes and can<br>
            take 2 forms, short or long.</p>
        <p class="a">If bit 8 equals 0, the length byte is short. In this form, bits 7 to 1 represent the<br>
            length of the contents bytes as an unsigned binary integer. The contents bytes<br>
            can only be less than or equal to 127 bytes with the short form.</p>
        <p class="a">Figure 43 shows the short form of a length byte with the value of 86 bytes.</p>
        <img src="sixhundred.PNG">
        <p class="a"><i>Figure 43. Length Byte in Short Form</i></p>
        <p class="a">If bit 8 equals 1, the length byte is long. For this form, bits 7 to 1 represent<br>
            the length of the contents bytes as an unsigned binary integer. Each<br>
            subsequent byte is an unsigned binary integer, and when added together,<br>
             represents the length of the contents bytes. If the contents bytes are greater<br>
            than 127 bytes, you must use the long form.</p>
        <p class="a">Figure 44 on page 223 shows the long form of a length byte with the value of<br>
            357 bytes. Two length bytes are needed to represent 357.</p>
        <img src="sevenhundred.PNG">
        <p class="a"><i>Figure 44. Length Byte in Long Form</i></p>
        <h4 class="heading">Null Value</h4>
        <p class="a">Length field is zero.</p>
        <h4 class="heading">PL/I Declaration</h4>
        <p class="a">% BERVar = ’CHAR(32767) VARYING’;</p>
        <h4 class="heading"> C Declaration</h4>
        <p class="a">typedef &nbsp;&nbsp;&nbsp;&nbsp;_Packed struct {<br>
            &nbsp;&nbsp;&nbsp;&nbsp;Smallint Length;<br>
            &nbsp;&nbsp;&nbsp;&nbsp; Anonymous Text[1];<br>
            &nbsp;&nbsp;&nbsp;&nbsp;} BERVar;</p>
        <h4 class="heading">CharVar<br>
            Data Type Identifier</h4>
            <p class="a">4</p>
            <h4 class="heading"> Description</h4>
            <p class="a">Variable-length character string of up through 32767 bytes. The structure of this<br>
                data type is a 2-byte length field followed by the characters in the string. CharVar<br>
                data can be optionally terminated with a null byte with value X'00' by the user for<br>
                C string support. When RODM formats character strings, it always adds the null<br>
                terminator. For example, a CharVar field specified with the null byte that contains<br>
                the string “RODM” has the value X'0004D9D6C4D400'. Note that the null<br>
                terminator byte is not included in the length field of the CharVar data.</p>
            <p class="a">For information about specifying a CharVar string in a SelfDefining data string, see<br>
                “SelfDefining” on page 233.
                </p>
            <p class="a">For DBCS (double-byte character set) support, the special control character<br>
                shift-out (X'0E') can begin a DBCS string, and the control character shift-in (X'0F')<br>
                can end a DBCS string. When embedded between the shift-out and shift-in control<br>
                characters, each double-byte character is counted as two bytes. In addition, the<br>
                shift-out and shift-in characters are included in the length of the DBCS string. The<br>
                valid double-byte characters are the same as those for the GraphicVar data type;<br>
                see “GraphicVar” on page 227.</p>
                <h4 class="heading">Null Value</h4>
                <p class="a">Length field is zero.</p>
                <h4 class="heading">PL/I Declaration</h4>
                <p class="a">% CharVar = ’CHAR(32767) VARYING’;</p>
                <h4 class="heading">C Declaration</h4>
                <p class="a">typedef   &nbsp;&nbsp;&nbsp;&nbsp;_Packed struct {<br>
                    &nbsp;&nbsp;&nbsp;&nbsp; Smallint Length;<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;char Text[1];<br>
                    &nbsp;&nbsp;&nbsp;&nbsp; } CharVar;</p>
                <h4 class="heading">CharVarAddr (Reserved)<br>
                    Data Type Identifier</h4>
                <p class="a">7</p>
                <h4 class="heading">Description</h4>
                <p class="a">Pointer to any variable-length character string. The pointer does not imply any<br>
                    maximum length requirements.</p>
                    <h4 class="heading">Null Value</h4>
                    <p class="a">NULL pointer</p>
                    <h4 class="heading">PL/I Declaration</h4>
                    <p class="a">% CharVarAddr = ’POINTER’;</p>
                    <h4 class="heading">C Declaration</h4>
                    <p class="a">typedef Pointer CharVarAddr;</p>
                    <h4 class="heading">ClassID (Reserved)<br>
                        Data Type Identifier</h4>
                        <p class="a">1</p>
                        <h4 class="heading">Description</h4>
                        <p class="a">A full-word integer that identifies a class to RODM. ClassID is the data type only<br>
of the MyID field on a class and the MyPrimaryParentID field on classes and<br>
objects.
<h4 class="heading">Null Value</h4>
<p class="a">All bits are zero.</p>
<h4 class="heading">PL/I Declaration</h4>
<p class="a">% ClassID = ’FIXED BINARY(31)’;</p>
<h4 class="heading">C Declaration</h4>
<p class="a">typedef long ClassID;</p>
<h4 class="heading">ClassID (Reserved)<br>
    Data Type Identifier</h4>
    <p class="a">2</p>
    <h4 class="heading">Description</h4>
    <p class="a">A list of Class IDs. This is the data type only of the MyClassChildren field of a<br>
        class. The Length field of ClassIDList is the number of elements in the list, not the<br>
        length in bytes.</p>
        <h4 class="heading">Null Value</h4>
        <p class="a">Length field is zero.</p>
        <h4 class="heading">PL/I Declaration</h4>
        <p class="a">DCL<br>
            1 ClassIDList EKG_BOUNDARY,<br>
            3 Len Integer,<br>
            3 List(1) ClassID;</p>
        <p class="a"><b class="bold">Note:</b> EKG_BOUNDARY is a character substitution for the UNALIGNED and<br>
            BASED PL/I attributes and is used with all abstract data type Pl/I definitions<br>
            using DCL statements.</p>
        <h4 class="heading">C Declaration</h4>
        <p class="a">typedef  &nbsp;&nbsp;&nbsp;&nbsp;_Packed struct {<br>
            &nbsp;&nbsp;&nbsp;&nbsp;Integer Length;<br>
            &nbsp;&nbsp;&nbsp;&nbsp;ClassID List[1];<br>
            &nbsp;&nbsp;&nbsp;&nbsp;} ClassIDList;</p>
        <h4 class="heading">ClassID (Reserved)<br>
            Data Type Identifier</h4>
            <p class="a">6</p>
            <h4 class="heading">Description</h4>
            <p class="a">A 4-byte length field followed by a list in which each entry is a concatenated Class<br>
                ID and Field ID. The Length field of ClassLinkList is the number of elements in the<br>
                list, not the length in bytes. Each entry specifies a link to some field of a class,<br>
                required for a system-class definition of the MyClassChildren field of a class.<br>
                </p>
                <h4 class="heading">Null Value</h4>
                <p class="a">Length field is zero.</p>
                <h4 class="heading">PL/I Declaration</h4>
                <p class="a">DCL<br>
                    &nbsp;&nbsp;&nbsp;&nbsp; 1 ClassLinkList EKG_BOUNDARY,<br>
                    &nbsp;&nbsp;&nbsp;&nbsp; 3 Len Integer,<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;3 List(1),<br>
                    &nbsp;&nbsp;&nbsp;&nbsp; 5 ClassIdentifier ClassID,<br>
                    &nbsp;&nbsp;&nbsp;&nbsp; 5 FieldIdentifier FieldID;</p>
                <p class="a"><b class="bold">Note:</b> EKG_BOUNDARY is a character substitution for the UNALIGNED and<br>
                    BASED PL/I attributes and is used with all abstract data type Pl/I definitions<br>
                    using DCL statements.</p>
                <h4 class="heading">C Declaration</h4>
                <p class="a">typedef &nbsp;&nbsp;&nbsp;&nbsp;_Packed struct {<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;Integer Length;<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;ClassLink List[1];<br>
                    &nbsp;&nbsp;&nbsp;&nbsp; } ClassLinkList;<br></p>
                <h4 class="heading">ClassID (Reserved)<br>
                    Data Type Identifier</h4>
                    <p class="a">8</p>
                    <h4 class="heading">Description</h4>
                    <p class="a">The 4-byte address of an ECB that the RODM program uses to post an application<br>
                        when an event occurs. The EKG_NotificationQueue class requires this data type.</p>
                        <h4 class="heading">Null Value</h4> 
                        <p class="a">Null pointer</p>
                        <h4 class="heading">PL/I Declaration</h4> 
                        <p class="a">% ECBAddress = ’POINTER’;</p>
                        <h4 class="heading"> C Declaration</h4> 
                        <p class="a">typedef void *ECBAddress;</p>
                        <h4 class="heading"> FieldID<br>
                        Data Type Identifier</h4> 
                        <p class="a">26</p>
                        <h4 class="heading">Description</h4> 
                        <p class="a">A full-word integer for field identifiers. This data type is used for fields that<br>
                        contain the identifier of other fields.</p>
                        <h4 class="heading">Null Value</h4> 
                        <p class="a">All bits are zero.</p>
                        <h4 class="heading">PL/I Declaration</h4> 
                        <p class="a">% FieldID = ’FIXED BINARY(31)’;</p>
                        <h4 class="heading">C Declaration</h4> 
                        <p class="a">typedef long FieldID;</p>
                        <h4 class="heading">Floating
                           Data Type Identifier</h4> 
                           <p class="a">9</p>
                        <h4 class="heading">Description</h4> 
                        <p class="a">A floating point number for general use. The number is represented in eight bytes.</p>
                        <h4 class="heading">Null Value</h4> 
                        <p class="a">All bits are zero.</p>
                        <h4 class="heading">PL/I Declaration</h4> 
                        <p class="a">% Floating = ’FLOAT BINARY(53)’</p>
                        <h4 class="heading">C Declaration</h4> 
                        <p class="a">typedef double Floating;</p>
                        <h4 class="heading">GraphicVar<br>
                            Data Type Identifier</h4>
                           <p class="a">5</p>
                        <h4 class="heading">Description</h4> 
                        <p class="a">A sequence of data constructed as a 2-byte length field followed by a set of<br>
                            double-byte characters. The value of the length field must be no more than 16,383<br>
                            double-byte units. One 16-bit double-byte character has a length of one<br>
                            double-byte unit. Valid characters must have both the first and second byte of data<br>
                            defined in the range X'41' through X'FE'. The characters X'4040' are also valid.<br>
                            GraphicVar data is terminated by two null bytes with value X'0000'. The null<br>
                            terminator bytes are not included in the length field of the GraphicVar data.</p>
                            <h4 class="heading">Null Value</h4> 
                            <p class="a">Length field is zero.</p>
                            <h4 class="heading">PL/I Declaration</h4> 
                            <p class="a">DCL<br>
                                &nbsp;&nbsp;&nbsp;&nbsp; 1 GraphicVar EKG_BOUNDARY,<br>
                                &nbsp;&nbsp;&nbsp;&nbsp; 3 Len Smallint,<br>
                                &nbsp;&nbsp;&nbsp;&nbsp; 3 Text CHAR(1);</p><br>
                            <h4 class="heading">C Declaration</h4> 
                            <p class="a">typedef&nbsp;&nbsp;&nbsp;&nbsp; _Packed struct {<br>
                                &nbsp;&nbsp;&nbsp;&nbsp;Smallint Length;<br>
                                &nbsp;&nbsp;&nbsp;&nbsp; Smallint Text[1];<br>
                                &nbsp;&nbsp;&nbsp;&nbsp;} GraphicVar</p>
                            <h4 class="heading">Integer<br>
                                Data Type Identifier</h4>
                               <p class="a">10</p>
                            <h4 class="heading">Description</h4> 
                            <p class="a">Full-word integer intended for general use.</p>
                            <h4 class="heading">Null Value</h4> 
                            <p class="a">All bits are zero.</p>
                            <h4 class="heading">PL/I Declaration</h4> 
                            <p class="a">% Integer = ’FIXED BINARY(31)’;</p>
                            <h4 class="heading">C Declaration</h4>
                            <p class="a">typedef long Integer;</p>
                            <h4 class="heading">IndexList<br>
                                Data Type Identifier</h4>
                               <p class="a">32</p>
                               <h4 class="heading">Description</h4> 
                               <p class="a">A variable-length string of data that is composed of multiple values up through a<br>
                                maximum of 32767 bytes. The data is a list of AnonymousVar data values, and<br>
                                each individual data value in the list has the following characteristics:</p>
                                <p class="a"><ul><li> Must be unique within the field.</li></ul></p>
                                <p class="a"><ul><li> Has a maximum length of 254 bytes</li></ul></p>
                                <p class="a"><ul><li>v Is composed of a 2-byte length field followed by the number of data bytes<br>
                                    specified by the length field. The AnonymousVar data type identifier is not part<br>
                                    of the value</li></ul></p>
                                <p class="a">Figure 45 shows an example Indexlist string that contains three AnonymousVar<br>
                                    values:</p>
                                <img src="eighthundred.PNG">
                                <p class="a"><i>Figure 45. Example IndexList Field</i></p>
                                <h4 class="heading">Null Value</h4> 
                                <p class="a">Length field is zero.</p>
                                <h4 class="heading">PL/I Declaration</h4> 
                                <p class="a">% IndexList = ’CHAR(32767) VARYING’;</p>
                                <h4 class="heading">C Declaration</h4>
                                <p class="a">typedef&nbsp;&nbsp;&nbsp;&nbsp; _Packed struct {<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;Smallint Length;<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;char Text[1];<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;} IndexList;</p>
                                    <h4 class="heading">MethodName (Reserved)<br>
                                        Data Type Identifier</h4>
                                        <p class="a">11</p>
                                        <h4 class="heading">Description</h4> 
                                        <p class="a">An 8-character data type for the name of a method.</p>
                                        <h4 class="heading">Null Value</h4> 
                                        <p class="a">NullMeth.</p>
                                        <h4 class="heading">PL/I Declaration</h4> 
                                        <p class="a">% MethodName = ’CHAR(8)’;</p>
                                        <h4 class="heading">C Declaration</h4>
                                        <p class="a">typedef  &nbsp;&nbsp;&nbsp;&nbsp;_Packed struct {<br>
                                            &nbsp;&nbsp;&nbsp;&nbsp;char Data_char[8];<br>
                                            &nbsp;&nbsp;&nbsp;&nbsp;} MethodName;</p>
                                            <h4 class="heading">method_parameter_list (Reserved)<br>
                                                Data Type Identifier</h4>
                                                <p class="a">12</p>
                                                <h4 class="heading">Description</h4> 
                                                <p class="a">Long-lived parameters retained by RODM and passed to a method. The maximum<br>
                                                    length is 254 bytes, excluding the 2-byte header of X'000C'.</p>
                                                    <h4 class="heading">Null Value</h4> 
                                                    <p class="a">Length field is zero</p>
                                                    <h4 class="heading">PL/I Declaration</h4> 
                                                    <p class="a">% method_parameter_list = ’SelfDefining’;</p>
                                                    <h4 class="heading">C Declaration</h4>
                                                <p class="a">typedef SelfDefining method_parameter_list</p>
                                                <h4 class="heading">MethodSpec<br>
                                                    Data Type Identifier</h4>
                                                    <p class="a">13</p>
                                                    <h4 class="heading">Description</h4> 
                                                    <p class="a">A method object ID plus a method parameter list that specify an object-specific<br>
                                                        method and the parameters that it has when you trigger it.</p>
                                                        <h4 class="heading">Null Value</h4> 
                                                        <p class="a">Method object ID for the reserved method named NullMeth concatenated with a<br>
                                                            null method parameter list.</p>
                                                            <h4 class="heading">PL/I Declaration</h4> 
                                                            <p class="a">DCL<br>
                                                                &nbsp;&nbsp;&nbsp;&nbsp; 1 MethodSpec EKG_BOUNDARY,<br>
                                                                &nbsp;&nbsp;&nbsp;&nbsp;3 ObjectIdentifier ObjectID,<br>
                                                                &nbsp;&nbsp;&nbsp;&nbsp;3 MthdParmList SelfDefining;</p>
                                    <h4 class="heading">C Declaration</h4>
                                    <p class="a">typedef&nbsp;&nbsp;&nbsp;&nbsp; _Packed struct {<br>
                                        &nbsp;&nbsp;&nbsp;&nbsp;ObjectID ObjectIdentifier;<br>
                                        &nbsp;&nbsp;&nbsp;&nbsp; SelfDefining MthdParmList;<br>
                                        &nbsp;&nbsp;&nbsp;&nbsp;} MethodSpec;</p>
                                    <h4 class="heading">ObjectID (Reserved)<br>
                                        Data Type Identifier</h4>
                                        <p class="a">14</p>
                                        <h4 class="heading">Description</h4> 
                                        <p class="a">Double word for an object ID, required on the MyID field of an object.
                                        </p>
                                        <h4 class="heading">Null Value</h4> 
                                        <p class="a">All bits are zero.</p>
                                        <h4 class="heading">PL/I Declaration</h4> 
                                        <p class="a">% ObjectID = ’BIT(64)’;</p>
                                        <h4 class="heading">C Declaration</h4>
                                        <p class="a">typedef &nbsp;&nbsp;&nbsp;&nbsp;_Packed struct {<br>
                                            &nbsp;&nbsp;&nbsp;&nbsp;Smallint Collision_number;<br>
                                            &nbsp;&nbsp;&nbsp;&nbsp;Smallint Class_identifier;<br>
                                            &nbsp;&nbsp;&nbsp;&nbsp;Integer Object_identifier;<br>
                                            &nbsp;&nbsp;&nbsp;&nbsp;} ObjectID;</p>
                                        <h4 class="heading">ObjectIDList (Reserved)<br>
                                            Data Type Identifier</h4>
                                            <p class="a">15</p>
                                            <h4 class="heading">Description</h4> 
                                            <p class="a">A list in which the entries are Object IDs. The data type of the MyObjectChildren<br>
                                                field on a class. A sequence of data constructed as a 4-byte length field followed by<br>
                                                a concatenation of the ObjectIDs that are the entries in the list. The Length field of<br>
                                                ObjectIDList is the number of elements in the list, not the length in bytes. All<br>
                                                object IDs in the list are concatenated and contiguous.</p>
    <h4 class="heading">Null Value</h4>
    <p class="a">Length field is zero</p>
    <h4 class="heading">PL/I Declaration</h4>
    <p class="a">DCL<br>
        &nbsp;&nbsp;&nbsp;&nbsp;1 ObjectIDList EKG_BOUNDARY,<br>
        &nbsp;&nbsp;&nbsp;&nbsp;3 Len Integer,<br>
        &nbsp;&nbsp;&nbsp;&nbsp; List(1) ObjectID;</p>
        <h4 class="heading">C Declaration</h4>
        <p class="a">typedef&nbsp;&nbsp;&nbsp;&nbsp; _Packed struct {<br>
            &nbsp;&nbsp;&nbsp;&nbsp; Integer Length;<br>
            &nbsp;&nbsp;&nbsp;&nbsp; ObjectID List[1];<br>
            &nbsp;&nbsp;&nbsp;&nbsp;} ObjectIDList;</p>
        <h4 class="heading">ObjectLink<br>
            Data Type Identifier</h4>
        <p class="a">16</p>
        <h4 class="heading">Description</h4> 
        <p class="a">Double-word object ID plus field ID for specifying a link to a field in another<br>
            object.</p>
            <h4 class="heading">Null Value</h4>
            <p class="a">A NULL Object ID concatenated with a NULL field ID.</p>
            <h4 class="heading">PL/I Declaration</h4>
            <p class="a">DCL<br>
                &nbsp;&nbsp;&nbsp;&nbsp; 1 ObjectLink EKG_BOUNDARY,<br>
                &nbsp;&nbsp;&nbsp;&nbsp; 3 ObjectIdentifier ObjectID,<br>
                &nbsp;&nbsp;&nbsp;&nbsp;3 FieldIdentifier FieldID;</p>
                <h4 class="heading">C Declaration</h4>
                <p class="a">typedef &nbsp;&nbsp;&nbsp;&nbsp; _Packed struct {<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;ObjectID ObjectIdentifier;<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;FieldID FieldIdentifier;<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;} ObjectLink;</p>
                <h4 class="heading">ObjectLinkList<br>
                    Data Type Identifier</h4>
                <p class="a">17</p>
                <h4 class="heading">Description</h4> 
                <p class="a">A list of Object Links. A sequence of data constructed as a 4-byte length field<br>
                    followed by the concatenation of the Object Links that are the entries in the list.<br>
                    The Length field of ObjectLinkList is the number of elements in the list, not the<br>
                    length in bytes. All object IDs in the list are concatenated and contiguous.</p>
                    <h4 class="heading">Null Value</h4>
                    <p class="a">Length field is zero</p>
                    <h4 class="heading">PL/I Declaration</h4>
                    <p class="a">DCL<br>
                        &nbsp;&nbsp;&nbsp;&nbsp; 1 ObjectLinkList EKG_BOUNDARY,<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;3 Len Integer,<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;3 List(1),<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;5 ObjectIdentifier ObjectID,<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;5 FieldIdentifier FieldID;</p>
                        <h4 class="heading">C Declaration</h4>
                    <p class="a">typedef  &nbsp;&nbsp;&nbsp;&nbsp;_Packed struct {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;Integer Length;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;ObjectLink List[1];<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;} ObjectLinkList;</p>
                    <h4 class="heading">ObjectName (Reserved)<br>
                        Data Type Identifier</h4>
                        <p class="a">18</p>
                        <h4 class="heading">Description</h4> 
                        <p class="a">The data type of the MyName field of an object. The name consists of no more<br>
                            than 254 characters, terminated by one byte of X'00'. The structure of ObjectName<br>
                            data is a 2-byte length field followed by the characters in the string. The null<br>
                            terminating character is not included in the length field. See “Object Names” on<br>
                            page 205 for information about valid object names.</p>
                            <h4 class="heading">Null Value</h4>
                            <p class="a">Length field is zero; in PL/I, set with string = '</p>
                            <h4 class="heading">PL/I Declaration</h4>
                            <p class="a">% ObjectName = ’CHAR(254) VARYING’;</p>
                            <h4 class="heading">C Declaration</h4>
                            <p class="a">typedef &nbsp;&nbsp;&nbsp;&nbsp; _Packed struct {<br>
                                &nbsp;&nbsp;&nbsp;&nbsp;Smallint Name_length;<br>
                                &nbsp;&nbsp;&nbsp;&nbsp;char Name_content[255];<br>
                                &nbsp;&nbsp;&nbsp;&nbsp;} ObjectName</p><br>
                                <h4 class="heading">RecipientSpec (Reserved)<br>
                                    Data Type Identifier</h4> 
                                    <p class="a">20</p>
                                    <h4 class="heading">Description</h4>
                                    <p class="a">Information that notification methods require to notify an application program. A<br>
                                        sequence of data including an 8-byte ApplicationID, an 8-byte notification-queue<br>
                                        SubscribeID, and an 8-byte user word of data type Anonymous.</p>
                                        <h4 class="heading">Null Value</h4>
                            <p class="a">Concatenation of a null Application ID, a null SubscribeID, and a null<br>
                                Anonymous(8) string</p>
                            <h4 class="heading">PL/I Declaration</h4>
                            <p class="a">DCL<br>
                                &nbsp;&nbsp;&nbsp;&nbsp; 1 RecipientSpec EKG_BOUNDARY,<br>
                                &nbsp;&nbsp;&nbsp;&nbsp;3 User_appl_ID ApplicationID,<br>
                                &nbsp;&nbsp;&nbsp;&nbsp;3 Notification_queue SubscribeID,<br>
                                &nbsp;&nbsp;&nbsp;&nbsp;3 User_word Anonymous(8);</p>
                                <h4 class="heading">C Declaration</h4>
                                <p class="a">typedef &nbsp;&nbsp;&nbsp;&nbsp; _Packed struct {<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;ApplicationID User_appl_ID;<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp; SubscribeID Notification_queue;<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;Anonymous User_Word[8];<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;} RecipientSpec;</p>
                                <h4 class="heading">SelfDefining<br>
                                    Data Type Identifier</h4>
                                <p class="a">19</p>
                                <h4 class="heading">Description</h4>
                                <p class="a">A string of no more than 32767 bytes that is a concatenation of tagged data items;<br>
                                    each tagged data item represents a RODM abstract data-type ID followed by its<br>
                                    corresponding data. All reserved abstract data types can be used in SelfDefining<br>
                                    data strings except the Anonymous(N) data type.</p>
                                <p class="a"><i>Figure 46 shows the format of SelfDefining data</i></p>
                                <h4>Self_Defining</h4>
                                <img src="ninehundred.PNG">
                                <p><i>Figure 46. SelfDefining Data Type Syntax</i></p>
                                <p class="a">The following variables are used in the SelfDefining syntax:</p>
                                <p class="a"><i>length</i></p>
                                <p class="b">A 2-byte integer that specifies the total length of the SelfDefining data string<br>
                                    excluding the 2-byte length field itself.</p>
                                    <p class="a"><i>identifier</i></p>
                                    <p class="b">A 2-byte unsigned integer that specifies the RODM data type of the data that<br>
                                        immediately follows the identifier in the SelfDefining data string. Data type<br>
                                        identifiers are specified in the RODM data type definitions in “Abstract Data<br>
                                        Type Reference” on page 219.</p><br>
                                        <p class="a"><i>value</i></p>
                                        <p class="b">The value of the data that is specified by identifier. For values that are of data<br>
                                            type ObjectName and ShortName, the null terminator is not included in the<br>
                                            SelfDefining data string.</p>
                                        <p class="a">When specifying a CharVar inside a SelfDefining data string, you must include the<br>
                                            1-byte null terminator in the length field of the SelfDefining data string, but do not<br>
                                            include it in the length field of the CharVar specification within the SelfDefining<br>
                                            data string</p>
<p class="a">Figure 47 on page 234 shows an example SelfDefining string that contains a<br>
    Smallint with a 2-byte (short integer) hexadecimal representation of the value 2010,<br>
     a CharVar with the value RODM, and an 8-byte application ID value of NETV, which<br>
    is padded on the right with four blanks.</p>
<img src="tenhundred.PNG">
<p><i>Figure 47. Example SelfDefining Field</i></p>
<h4 class="heading">Null Value</h4>
<p class="a">Length field is zero.</p>
<h4 class="heading">PL/I Declaration</h4>
<p class="a">% SelfDefining = ’CHAR(32767) VARYING’;</p>
<h4 class="heading">C Declaration</h4>
<p class="a">typedef&nbsp;&nbsp;&nbsp;&nbsp; _Packed struct {<br>
    &nbsp;&nbsp;&nbsp;&nbsp;Smallint Data_length;<br>
    &nbsp;&nbsp;&nbsp;&nbsp;Anonymous Data_content;<br>
    &nbsp;&nbsp;&nbsp;&nbsp;} SelfDefining;</p>
<h4 class="heading">ShortName (Reserved)<br>
    Data Type Identifier</h4>
<p class="a">23</p>
<h4 class="heading">Description</h4>
<p class="a">Data type of the MyName field on a class and MyPrimaryParentName field on any<br>
    object or class. The name consists of no more than 64 characters, terminated by one<br>
    byte of X'00'. The structure of ShortName data is a 2-byte length field followed by<br>
    the characters in the string. For information about constructing field names, see<br>
    “RODM Fields” on page 206.
    </p>
    <h4 class="heading">Null Value</h4>
    <p class="a">Length field is zero; in PL/I, set with string = '.</p>
    <h4 class="heading">PL/I Declaration</h4>
    <p class="a">% ShortName = ’CHAR(64) VARYING’;</p>
    <h4 class="heading">C Declaration</h4>
    <p class="a">typedef  &nbsp;&nbsp;&nbsp;&nbsp;_Packed struct {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;short Name_length;<br>
        &nbsp;&nbsp;&nbsp;&nbsp; char Name_content[65];<br>
        &nbsp;&nbsp;&nbsp;&nbsp;} ShortName;</p>
        <h4 class="heading">Smallint<br>
            Data Type Identifier</h4>
    <p class="a">21</p>
    <h4 class="heading">Description</h4>
    <p class="a">A 2-byte (half-word) signed integer for general use.</p>
    <h4 class="heading">Null Value</h4>
    <p class="a">All bits are zero.</p>
    <h4 class="heading">PL/I Declaration</h4>
    <p class="a">% Smallint = ’FIXED BINARY(15)’;</p>
    <h4 class="heading">C Declaration</h4>
    <p class="a">typedef short Smallint;</p>
    <h4 class="heading">SubscribeID (Reserved)<br>
        Data Type Identifier</h4>
    <p class="a">22</p>
    <h4 class="heading">Description</h4>
    <p class="a">The 8-character notification queue name that is used to associate a field with a<br>
        notification queue when the field is subscribed to. The association is established<br>
        during the subscription process. The characters are positioned left-justified within<br>
        the eight bytes and padded with blanks (for code page 00500, X'40') on the right.</p>
        <h4 class="heading">Null Value</h4>
        <p class="a">All bytes are blank (X'40' for code page 00500).
        </p>
        <h4 class="heading">PL/I Declaration</h4>
        <p class="a">% SubscribeID = ’CHAR(8)’;</p>
        <h4 class="heading">C Declaration</h4>
        <p class="a">typedef&nbsp;&nbsp;&nbsp;&nbsp; _Packed struct {<br>
            &nbsp;&nbsp;&nbsp;&nbsp;char Data_char[8];<br>
            &nbsp;&nbsp;&nbsp;&nbsp;} SubscribeID;</p>
        <h4 class="heading">SubscriptSpec (Reserved)<br>
            Data Type Identifier</h4>
        <p class="a">24</p>
        <h4 class="heading">Description</h4>
        <p class="a">A method specification plus a recipient specification used to record a notification<br>
            request in the RODM program. The SubscriptSpec includes information about the<br>
            method, the method parameters, and the intended recipient of the notification.</p>
            <h4 class="heading">Null Value</h4>
            <p class="a">Concatenation of a null MethodSpec and a null RecipientSpec

            </p>
            <p class="a"><b class="bold">Note:</b>The MethodSpec data type, a part of the SubscriptSpec data type, consists of<br>
                an ObjectID and a method parameter list. The method parameter list is<br>
                self-defining and is, in PL/I syntax, CHAR(254) VARYING.</p>
            <h4 class="heading">SubscriptSpecList (Reserved)<br>
                Data Type Identifier</h4>
            <p class="a">25</p>
            <h4 class="heading">Description</h4>
            <p class="a">The data type of a notify subfield. This data type contains a list of SubscriptSpec<br>
                elements, where each SubscriptSpec element represents a notification subscription.<br>
                The length field of SubscriptSpecList is the number of elements in the list, not the<br>
                length in bytes. All SubscriptSpec elements in the list are concatenated and<br>
                contiguous.</p>
                <h4 class="heading">Null Value</h4>
        <p class="a">All bits are zero
        </p>
        <h4 class="heading">PL/I Declaration</h4>
        <p class="a">DCL<br>
            &nbsp;&nbsp;&nbsp;&nbsp;1 SubscriptSpecList EKG_BOUNDARY,<br>
            &nbsp;&nbsp;&nbsp;&nbsp;3 Len Integer,<br>
            &nbsp;&nbsp;&nbsp;&nbsp;3 Text CHAR(1);</p>
            <h4 class="heading">C Declaration</h4>
            <p class="a">typedef&nbsp;&nbsp;&nbsp;&nbsp; _Packed struct {
                &nbsp;&nbsp;&nbsp;&nbsp;Integer Length;
                &nbsp;&nbsp;&nbsp;&nbsp;char Text[1];
                &nbsp;&nbsp;&nbsp;&nbsp;} SubscriptSpecList;</p>
            <h4 class="heading">TimeStamp<br>
                Data Type Identifier</h4>
                <p class="a">27</p>
                <h4 class="heading">Description</h4>
                <p class="a">The time value represented in Lilian milliseconds (eight bytes). Lilian milliseconds<br>
                    is the number of milliseconds since midnight 14 October 1582, which marks the<br>
                    beginning of the use of the Gregorian calendar. The time range provided is from 14<br>
                    October 1582 through 31 December 9999. This is similar to the time format that is<br>
                    supported by the Common Execution Library for IBM compilers. To use this time<br>
                    with the Common Execution Library routines, divide the value by 1000.</p>
                <p class="a">Generation of this time format assumes that the Time-of-day (TOD) clock is set to<br>
                    Greenwich Mean Time (GMT) and based on the standard epoch.</p>
                <h4 class="heading">Null Value</h4>
                <p class="a">All bits are zero.</p>
                <h4 class="heading">PL/I Declaration</h4>
                <p class="a">% TimeStamp = ’FLOAT BINARY(53)’;</p>
                <h4 class="heading">C Declaration</h4>
                <p class="a">typedef double TimeStamp;</p>
                <h4 class="heading">TransID (Reserved)<br>
                    Data Type Identifier</h4>
                <p class="a">28</p>
                <h4 class="heading">Description</h4>
                <p class="a">The transaction ID is a unique identifier of a RODM transaction.</p>
                <h4 class="heading">Null Value</h4>
                <p class="a">All bits are zero.</p>
                <h4 class="heading">PL/I Declaration</h4>
                <p class="a">% TransID = ’CHAR(8)’;</p>
                <h4 class="heading">C Declaration</h4>
                <p class="a">typedef  &nbsp;&nbsp;&nbsp;&nbsp;_Packed struct {<br>
                    &nbsp;&nbsp;&nbsp;&nbsp; char Content[8];<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;} TransID</p>
                    <hr class="hr">
                    <h2>Chapter 10. Using the RODM Load Function</h2>
                    <p class="a">This chapter describes how to create your own data model and load object<br>
                        definitions using the RODM load function. You create a data model as part of<br>
                        creating a new RODM application that does not use a data model that is supplied<br>
                        by IBM. This can be done by modifying an existing model or creating an entirely<br>
                        new data model using RODM load function statements.<br>
                        </p>
                    <p class="a">The RODM load function enables you to create a data model and define its initial<br>
                        data values. It enables you to create, modify, and delete RODM classes and objects<br>
                        while the RODM program is running. You create sequential data sets that contain<br>
                        the load function statements. The load function reads the input data sets and loads<br>
                        the information into the RODM data cache.</p>
                    <p class="a">This section covers these topics:</p>
                    <p class="a">
                        <ul>
                            <li>Considerations when designing a data model</li>
                            <li> Introduction to the RODM load function</li>
                            <li>Using load function statements</li>
                            <li>Process for loading the data cache</li>
                            <li>Load function reference</li>
                        </ul>
                    </p>
                    <p clas="a">You can use the load function to update an existing data model while RODM is<br>
                        running. You can run the load function using an initialization method so that it<br>
                        runs before RODM accepts any other transactions.</p>
                    <hr class="hr">
                    <h2>Considerations When Designing a Data Model</h2>
                    <p class="a">RODM classes can have objects as children, other classes as children, or both<br>
                        objects and other classes as children. You can add a new class or a new object to a<br>
                        parent class, as shown in Figure 48.</p>
                    <img src="im1.PNG">
                    <p class="a"><i>Figure 48. Adding Objects and Classes</i></p>
                    <hr class="hr">
                    <h2>Introduction to the RODM Load Function</h2>
                    <p class="a">The RODM load function is a part of RODM that shares libraries with RODM, but<br>
                        operates like an application program through the RODM user application program<br>
                        interface (API). It performs operations on the RODM data cache using load<br>
                        function statements. You code these statements in sequential files which are used<br>
                        as input to the RODM load function.</p>
                    <h3 class="heading1">Load Function Statements</h3>
                    <p class="a">Two different levels of load function statements are processed by the RODM load<br>
                        function:</p>
                    <p class="a"><ul>
                        <li>
                             High-level load function statements
                        </li>
                        <li>Load function primitive statements</li>
                    </ul></p>
                    <p class="a">RODM <i>high-level</i> load function statements are the statements most commonly<br>
                        used when defining your data model hierarchy. During RODM load function<br>
                        processing each of these statements is parsed into one or more RODM load<br>
                        function primitive statements. These primitive statements are then processed for<br>
                        syntax and action.</p>
                        <p class="a">RODM load function <i>primitive</i> statements are the low-level syntax statements.<br>
                            They are either generated by the RODM load function from processing high-level<br>
                            statements or used directly as input to the RODM load function for loading and<br>
                            managing the RODM data cache. Each primitive statement corresponds closely to a<br>
                            user API call, but in some cases can include more than one user API call.</p>
                        <p class="a">In addition, there are <i>common syntactic elements</i> which are a group of described<br>
                            variables used in RODM high-level load function syntax and RODM load function<br>
                            primitive syntax.
                            </p>
                        <h3 class="heading1">Load Function Operations</h3>
                        <p class="a">The RODM load function provides three different operations that enable you to<br>
                            load, update, and validate the contents of the RODM data cache. These three<br>
                            operations are:</p>
                            <p class="b">
                                <ul>
                                    <li>Parse</li>
                        <li>Load</li>
                                    <li> Verify</li>
                                </ul>
                            </p>
                            <p class="a">The <i>parse</i> operation processes the load function input files and tests the syntax of<br>
                                all of the statements. No changes are made to the data cache, and RODM does not<br>
                                need to be running when you use the parse operation. This operation returns error<br>
                                messages for any statements in the load function input files that contain syntax<br>
                                errors. However, it cannot generate errors for problems such as assigning a value<br>
                                to a field that does not exist.</p>
                            <p class="a">The <i>load</i> operation parses the load function input files and updates the contents of<br>
                                the RODM data cache. The load function input files can contain both high-level<br>
                                load function statements and load function primitive statements.</p>
                            <p class="a">The RODM load function returns error messages for any statements in the load<br>
                                function input files that contain syntax errors. The load function also returns error<br>
                                messages for any request that does not complete successfully, even if the syntax<br>
                                was correct. For example, if you try to assign a value to a field which does not<br>
                                exist, the load function returns an error. Because the load function converts each<br>
                                high-level load function statement into several load function primitive statements<br>
                                as part of its processing, you might receive error messages which describe<br>
                                problems with load function primitives when you code a high-level load function<br>
                                statement.</p>
                            <p class="a">Before you run the load operation, run the parse operation and correct any syntax<br>
                                errors. Then, use the load operation to create or update the contents of the data<br>
                                cache. You can update the data cache using the load function any time RODM is<br>
                                running.</p>
                            <p class="a">The <i>verify</i> operation parses the load function input files and compares the<br>
                                statements with the contents of the data cache. No changes are made to the data<br>
                                cache, but RODM must be running to use the verify operation. The verify<br>
                                operation enables you to determine if specified classes, objects, and fields exist in<br>
                                the data cache. You can also determine if a field has a specified value. See<br>
                                “Understanding the Verify Operation” on page 258 for a more detailed description<br>
                                of the verify operation.
                                </p>
                            <h3 class="heading1">Loading the RODM Data Cache</h3>
                            <p class="a">After you create the RODM load function input files, you need to run the load<br>
                                function to load the RODM data cache. You call the RODM load function as any of<br>
                                the following items:</p>
                            <p class="b">
                                <ul>
                                    <li>An initialization method run at RODM start</li>
                                    <li>A module call from a program</li>
                                    <li>v A JCL batch job</li>
                                </ul>
                            </p>
                            <p class="a">You have different types of loads from which to choose:</p>
                            <p class="a">Initialization</p>
                            <p class="b">You load the methods, the class structure, and the object definitions at<br>
                                RODM start.</p>
                                <p class="a">Structure only</p>
                                <p class="b">You load only the methods and the class structure definitions—a structure<br>
                                    load.</p>
                                <p class="a">Object only</p>
                                <p class="b">You load only the object definitions—an object load.</p>
                                <p class="a">The RODM load function loads the RODM data cache with a data model based on<br>
                                    definitions in the load function input data sets. These data sets are identified to the<br>
                                    RODM load function by the JCL data definition (DD) statements labeled:</p>
                                <p class="a">EKGIN1</p>
                                <p class="b">Class structure definitions</p>
                                <p class="a">EKGIN2</p>
                                <p class="b">Method name table</p>
                                <p class="a">EKGIN3</p>
                                <p class="b">Object definitions</p>
                                <p class="a">For more information about loading the RODM data cache, see “Process for<br>
                                    Loading the RODM Data Cache” on page 244.</p>
                                <hr class="hr">
                                <h2>Using Load Function Statements</h2>
                                <p class="a">This section describes the RODM high-level load function statements and the<br>
                                    RODM load function primitive statements, and when to use them. The RODM<br>
                                    load function uses these statements to issue RODM user API calls that cause<br>
                                    RODM to:</p>
                                    <p class="b">
                                        <ul>
                                            <li>Create classes, objects, fields, and subfields</li>
                                            <li>Delete classes, objects, fields, and subfields</li>
                                            <li>Set fields to initial values</li>
                                            <li>Establish the parent-child relations that define the hierarchy</li>
                                            <li>Set the values of fields</li>
                                            <li>v Trigger methods</li>

                                        
                                        </ul>
                                    </p>
                                    <h3 class="heading1">High-Level Load Function Statements</h3>
                                    <p class="a">This topic describes the RODM high-level load function statements. For<br>
                                        information about coding these statements, see “Coding RODM High-Level Load<br>
                                        Function Statements” on page 273.</p>
                                    <p class="a">The four RODM high-level load function statements are:</p>
                                    <h4 class="heading">MANAGED OBJECT CLASS</h4>
                                    <p class="b">The RODM high-level load function class structure syntax you use to build<br>
                                        the hierarchy of the data model in the RODM data cache by adding class<br>
                                        definitions and setting initial values.</p>
                                        <h4 class="heading">CREATE</h4>
                                        <p class="b">The RODM high-level load function object syntax you use to create an<br>
                                            object of a class in the RODM data cache.</p>
                                        <h4 class="heading">DELETE</h4>
                                        <p class="b">The RODM high-level load function object syntax you use to delete an<br>
                                            object from the RODM data cache.
                                            </p>
                                        <h4 class="heading">SET</h4>
                                        <p class="b">The RODM high-level load function object syntax you use to set the values<br>
                                            of fields of objects in the RODM data cache.</p>
                                        <p class="a">When RODM high-level load function statements are processed, each RODM<br>
                                            high-level load function statement is first converted to RODM load function<br>
                                            primitive statements. For example, the following MANAGED OBJECT CLASS<br>
                                            high-level load function statement defines a child class named SNA_Domain_Class<br>
                                            with a field named SNANet under the class named Domain_Parent_Class:</p>
                                        <img src="im2.PNG">
                                        <p class="a">The high-level statement is parsed by the RODM load function and results in the<br>
                                            following RODM load function primitive statements:</p>
                                        <p class="b">OP SNA_Domain_Class HAS_PARENT Domain_Parent_Class;<br>
                                            OP SNA_Domain_Class HAS_FIELD (CHARVAR) SNANet;</p>
                                            <p class="a">Each RODM load function primitive statement is then processed for syntax and<br>
                                                action. See “Load Function Primitive Statements” on page 243 for more<br>
                                                information about RODM load function primitive statements.</p>
                                            <p class="a">If any of the RODM load function primitive statements generated for a RODM<br>
                                                high-level load function statement encounters an error, any subsequent RODM<br>
                                                load function primitive statements for that RODM high-level load function<br>
                                                statement will be ignored. That means any syntax errors following the detected<br>
                                                error within the bounds of the RODM high-level load function statement being<br>
                                                processed will not be detected.</p>
                                            <h3 class="heading1">Load Function Primitive Statements</h3>
                                            <p class="a">The RODM load function primitives are an external interface that is at a lower<br>
                                                level than the RODM high-level load function statements described in “High-Level<br>
                                                Load Function Statements” on page 242. For information about how to code<br>
                                                RODM load function primitive statements, see “Coding RODM Load Function<br>
                                                Primitive Statements” on page 281.</p>
                                            <p class="a">RODM load function primitives come directly from user-generated input files or<br>
                                                are generated by the RODM load function from RODM high-level load function<br>
                                                statements within the input files. Both RODM load function primitives and RODM<br>
                                                high-level load function statements can be used in the same RODM load function<br>
                                                input file, but load function primitives cannot be coded within a high-level<br>
                                                statement.</p>
                                            <p class="a">The load function processes primitive statements sequentially, one primitive<br>
                                                statement at a time. The RODM load function interprets each of them according to<br>
                                                their processing options and issues the appropriate user API calls to perform<br>
                                                RODM functions. The primitives correspond very closely to the user API calls, but<br>
                                                in some cases they can include more than one user API call.

                                                </p>
                                     <h3 class="heading1">When to Use High-Level or Primitive Load Function<br>
                                        Statements</h3>
                                        <p class="a">Use RODM high-level load function statements when you are:</p>
                                        <p class="a">
                                            <ul>
                                                <li>Performing the initial loading of a data model</li>
                                                <li> Making changes to the structure of the data model</li>
                                                <li>Adding a large number of classes or objects into the RODM data cache, where<br>
                                                    using RODM load function primitives is cumbersome</li>
                                               
                                            </ul>
                                        </p>
                                        <p class="a">Use RODM load function primitives to define class structure changes that involve<br>
                                            the deletion of classes, the modification of classes, the modification of the<br>
                                            hierarchy, or when a desired function cannot be performed by a high-level<br>
                                            statement.</p>
                                        <p class="a">The following RODM load function primitives perform functions that cannot be<br>
                                            performed by RODM high-level load function statements for objects or classes:</p>
                                       <h4 class="heading">FORCE_HAS_NO_INSTANCE</h4>
                                       <p class="b">Unconditionally, deletes an object after unlinking any links the object has</p>
                                       <h4 class="heading">FORCE_NOT_A_CLASS</h4>
                                       <p class="b">Unconditionally, deletes a class and any children of the class, regardless of<br>
                                        links</p>
                                       <h4 class="heading">HAS_NO_FIELD</h4>
                                       <p class="b">Deletes a field within a class</p>
                                       <h4 class="heading">HAS_NO_SUBFIELD</h4>
                                       <p class="b">Deletes a subfield within a field.</p>
                                       <h4 class="heading">INVOKED_WITH</h4>
                                       <p class="b">Triggers a named or object-independent method</p>
                                       <h4 class="heading">NOT_A_CLASS</h4>
                                       <p class="b">Conditionally deletes a childless class.</p>
                                       <p class="a">The following RODM load function primitives perform functions that cannot be<br>
                                        performed on classes by RODM high-level load function statements:</p>
                                        <p class="a"><b class="bold">Note:</b> RODM high-level load function statements can perform these functions on<br>
                                            objects</p>
                                       <h4 class="heading">HAS_VALUE</h4>
                                       <p class="b">Defines a value for a field within a class.</p>
                                       <p class="b">The RODM high-level load function statement MANAGED OBJECT<br>
                                        CLASS can define an initial value for the field of a specific class, but it<br>
                                        cannot be used to change the value.</p>
                                       <h4 class="heading">INHERITS</h4>
                                       <p class="b">Removes the locally defined value for the specified class field and reverts<br>
                                        the field value to the value that it inherited from its parent.</p>
                                       <h4 class="heading">SUBFIELD_HAS_VALUE</h4>
                                       <p class="b">Defines a value for a subfield within a class.
                                    </p>
                                    <p class="b">Only the value subfield can be initialized for the class by the RODM<br>
                                        high-level load function statement MANAGED OBJECT CLASS.</p>
                                       <h4 class="heading">SUBFIELD_INHERITS</h4>
                                       <p class="b">Removes the locally-defined value for the specified class subfield and<br>
                                        reverts the subfield value to the value that it inherited from its parent.</p>
                                       
                                       <p class="a">You can code the primitives for either a structure load or an object load, but you<br>
                                        must define all of the structure first and then define the objects because you must<br>
                                        ensure that parent classes are created before their class children or their object<br>
                                        children are created.</p>
                                      <p class="a">When it is easier to perform an operation with a RODM load function primitive<br>
                                        than with a RODM high-level load function statement, use a RODM load function<br>
                                        primitive. For example, the field value of the field named SNANet of the object<br>
                                        named CNM01 under the class named SNA_Domain_Class can be set to a new<br>
                                        value with the SET high-level statement, but you need several lines of SET<br>
                                        statement syntax:</p>
                                        <img src="im3.PNG">
                                        <p class="a">Whereas, you can use the HAS_VALUE primitive to set the field value of the object<br>
                                            with only one line of syntax:<br>
                                            OP SNA_Domain_Class.CNM01.SNANet HAS_VALUE (CHARVAR) ’NETC’;</p>
                                        <hr class="hr">
                                        <h2>Process for Loading the RODM Data Cache</h2>
                                        <p class="a">This section describes the process used to load the RODM data cache using the<br>
                                            RODM load function. The process steps are first listed in order and described in<br>
                                            the same order.</p>
                                        <p class="a">Loading the RODM data cache involves the following steps:</p>
                                        <p class="a">
                                            1. “Identifying the Methods to Install”<br>
2. “Creating the Class Structure and Object Definitions”<br>
3. “Deciding on the Type of Load” on page 246<br>
4. “Running the RODM Load Function” on page 248<br>
5. “Checking the Output Listings” on page 253<br>
                                        </p>
                                        <p class="a">You can use optional steps to change member names and parameter mapping:<br>
                                            <ul>
                                                <li>Modify the control table; see “Control Table—EKGCTABL” on page 260.</li>
                                                <li>Modify the parameter mapping table; see “Parameter Mapping Table” on page<br>
                                                    262.</li>
                                            </ul></p>
                                            <h3 class="heading1">Identifying the Methods to Install</h3>
                                            <p class="a">When you load the class structure as part of an initial load or a class structure<br>
                                                change, you can also install the methods. You identify the methods to be installed<br>
                                                in the RODM address space in the method name table (EKGINMTB). The table is a<br>
                                                member of the partitioned data set identified by the EKGIN2 DD statement. See<br>
                                                “Method Name Table” on page 261 for information about the format of the table<br>
                                                and other associated DD statements.</p>
                                            <p class="a">When you run the RODM load function and specify LOAD=STRUCTURE, the<br>
                                                RODM load function performs the following steps for each method name specified<br>
                                                in the method name table:<br>
                                                1. Searches STEPLIB DD data sets to ensure method is available<br>
                                                2. Creates a method object<br>
                                                3. Installs the method</p>
                                                <p class="a">If the method is already installed or is specified twice in the method name table,<br>
                                                    the RODM load function will issue the error message:<br>
                                                    EKG8568W -</p>
                                                <p class="a">THE METHOD method_name HAS NOT BEEN INSTALLED AS IT ALREADY EXISTS</p>
                                                <p class="a">You must have an EKGIN2 file. If you are installing no methods, the EKGIN2 file<br>
                                                    is an empty file. The methods must reside in one of the data sets identified by the<br>
                                                    STEPLIB DD statement in the target RODM start up JCL</p>
                                                <h3 class="heading1">Creating the Class Structure and Object Definitions</h3>
                                                <p class="a">Create sequential files that contain your class structure and object definitions, when<br>
                                                    you are:<br>
                                                    <ul>
                                                      <li>Performing the initial load of the class structure and object definitions into the<br>
                                                    RODM data cache</li>
                                                    <li>Making changes to the structure of the data model or defined objects in the data<br>
                                                    cache</li></ul></p>
                                                    <p class="a">These definitions consist of RODM high-level load function statements and RODM<br>
                                                        load function primitives. See “Using Load Function Statements” on page 242 for<br>
                                                        more information about using RODM high-level load function statements and<br>
                                                        RODM load function primitives.</p>
                                                    <h4 class="heading">Data Definition Statement Labels</h4>
                                                    <p class="a">The RODM load function expects to find the DD statements that declare the<br>
                                                        sequential data set or the concatenation of sequential data sets that contain the<br>
                                                        load function input definitions to be labeled:</p>
<p class="a"><ul>
    <li> EKGIN1 for the class structure definitions</li>
    <li>EKGIN3 for the object definitions</li>

</ul></p>
<p class="a">Although this is the load function's expectation, practically, you can put all your<br>
    definitions into a single sequential data set or concatenation of sequential data sets.<br>
    You choose either EKGIN1 or EKGIN3 as the DD name of the DD statement that<br>
    identifies the data set depending on the type of load. See “Deciding on the Type of<br>
    Load” for information about the type of load dependency.</p>
<p class="a">This technique is especially useful for incremental data cache changes, but it is<br>
    very important that you observe the concatenation caveats described in<br>
    “Concatenation of Data Sets.”</p>
    <h4 class="heading">Concatenation of Data Sets</h4>
    <p class="a">You can divide the class structure and object definitions into several sequential<br>
        data sets and then concatenate the data sets that contain these definitions. The<br>
        order of the data sets in the concatenation is important. Whether you use RODM<br>
        high-level load function statements or RODM load function primitives, you must<br>
        arrange the files containing the definitions so that: </p>
        <p class="a"><ul>
            <li>v RODM load function creates any parent class before it creates its children</li>
            <li>Class structure definitions precede any associated object definitions</li>
            <li>The statements that create objects are processed before the statements that create<br>
                links between objects</li>
        </ul></p>
<p class="a">You can concatenate object definitions so that each data set contains one or more<br>
    object definitions, and a data set can represent a domain, a subarea, or whatever<br>
    makes sense. By structuring your data sets in this way, you can facilitate adding or<br>
    refreshing information for a domain.
    </p>
    <h4 class="heading">Definition Examples</h4>
<p class="a">RODM provides two sample files in the samples library partitioned data set named<br>
    CNMSAMP.</p>
    <h4 class="heading">Member</h4>
    <p class="b">Contents</p>
    <h4 class="heading">EKGIN1</h4>
    <p class="b">An example of load function statements designed to:
        <ul class="ul1">
            <li> Create a class under the UniversalClass</li>
            <li> Create fields for all data types supported</li>
            <li>Set initial values for the fields</li>
        </ul>
    </p>
    <h4 class="heading">EKGIN3</h4>
    <p class="b">An example of load function statements designed to:
        <ul class="ul1">
            <li>Create 3 objects</li>
            <li>Set initial values</li>
           
        </ul>
    </p>
    <h3 class="heading1">Deciding on the Type of Load</h3>
    <p class="a">The steps in the loading process differ, depending on how you intend to run the<br>
        RODM load function and on what type of load you are performing. You can run<br>
        the RODM load function as an initialization method during a cold start of RODM<br>
        or during a warm start of RODM. You can run the RODM load function by means<br>
        of a JCL job. You can run the RODM load function by means of a module call from<br>
        an application. The RODM load function offers the following load types:<br>
    <ul>
        <li>“Initialization Load” on page 247</li>
        <li> “Structure Load Only” on page 247</li>
        <li>v “Object Load Only” on page 248</li>
    </ul></p>
    <h4 class="heading">Initialization Load</h4>
    <p class="a">In an initialization load, you can load the class structure, the names of the methods<br>
        to install, and the object definitions. This is done at RODM cold start by invoking<br>
        EKGLISLM.</p>
        <p class="a">Initialization requires three DD statements for input data with the following labels:</p>
        <h4 class="heading">EKGIN1</h4>
        <p class="b">Class structure definitions</p>
        <h4 class="heading">EKGIN2</h4>
        <p class="b">Method name table</p>
        <h4 class="heading">EKGIN3</h4>
        <p class="b">Object definitions</p>
        <p class="a">When RODM initialization takes place, the RODM load function (EKGLISLM), is<br>
            triggered to create the RODM structure. This initial load method runs an<br>
            object-independent method that sets the values of the objects in the RODM data<br>
            cache. After completion of the initial load, further changes are usually<br>
            modifications of defined objects or the addition of new object definitions.</p>
        <p class="a">In an initial load, you cannot directly specify the RODM load function parameters.<br>
            RODM uses a parameter mapping table (EKGPTENU). If you want to change the<br>
            default values of the parameters, change the default values in the parameter<br>
            mapping table. When the load function is initially run, the load function<br>
            parameters get their default values from the parameter mapping table. However, <br>
            the load function ignores any abbreviations or string substitutions in the table. See<br>
            “Parameter Mapping Table” on page 262 for information about creating your own<br>
            parameter mapping table or modifying the table copied during RODM installation.<br>
            For a display of the parameter mapping table that EKGPTENU supplied with<br>
            RODM, see Figure 60 on page 263.</p>
            <h4 class="heading">Structure Load Only</h4>
            <p class="a">A <i>structure load </i>is a load in which you load only the methods and the class<br>
                structure into RODM. This is generally done as a job containing JCL or a module<br>
                call while RODM is running.</p>
            <p class="a"><b class="bold">EKGIN2 Data Definition:</b> RODM load function first processes the data definition<br>
                statement with the label EKGIN2, which specifies the partitioned data set that<br>
                contains the method name table in one of its members. The name of the member<br>
                that contains the method name table is found by RODM in the control table<br>
                EKGCTABL. For information about control table EKGCTABL and how to<br>
                optionally modify or create a new table, see “Control Table—EKGCTABL” on page<br>
                260.
                </p>
            <p class="a">For each entry in the method name table, the RODM load function:<br>
                1. Searches the data sets identified by the STEPLIB DD statement in the RODM<br>
                start up JCL to see if the method is installed. If the method is not installed, a<br>
                return code of 8 and a reason code of 81 is returned and the load function<br>
                issues an error message.<br>
                2. Converts into RODM user API calls the load function primitives that associate<br>
                the entries in the method name table with the MethodName fields of the<br>
                appropriate classes. In other words, adds an object to the RODM EKG_Method<br>
                class.<br>
                3. Loads the method into the RODM address space.</p>
                <p class="a"><b class="bold">EKGIN1 Data Definition:</b> During a structure load, whether an initial structure<br>
                    load or a structure change, the RODM load function processes the EKGIN1 data<br>
                    definition statement after the EKGIN2 data definition statement processing is<br>
                    complete.</p>
                <p class="a">EKGIN1 identifies the sequential data set or concatenation of sequential data sets<br>
                    that contain the load function input statements that specify the classes and their<br>
                    parents.</p>
                <p class="a">The RODM load function reads this input as a stream of class definitions in<br>
                    sequential order, and parses all RODM high-level load function statements into<br>
                    RODM load function primitives. The RODM load function then converts the load<br>
                    function primitives to a succession of RODM user API calls, which create the<br>
                    classes in your RODM data cache.</p>
                <p class="a">When concatenating data sets, the order of the data sets in the EKGIN1 DD<br>
                    statement is important. Load the data sets that contain parent classes before those<br>
                    that contain their children. Figure 49 shows a concatenation of data sets for the<br>
                    EKGIN1 DD statement.</p>
                <img src="im4.PNG">
                <p class="a">Figure 49. Data Set Concatenation for EKGIN1</p>
                <h4 class="heading">Object Load Only</h4>
                <p class="a">In an object load, you can load only the object definitions. You can load object<br>
                    definitions as a job or as a module call while RODM is running. The object load<br>
                    uses one DD statement labeled EKGIN3 to identify the sequential data set or<br>
                    concatenation of sequential data sets that contain the object definitions for the load.</p>
                <p class="a">When you concatenate data sets, be sure that the statements that create objects are<br>
                    processed before the statements that create links between objects. Both objects<br>
                    being linked must be in RODM when the link statement is processed.<br>
                    Concatenation takes the standard z/OS format for concatenated data sets. Figure 50<br>
                    shows a concatenation of data sets for the EKGIN3 DD statement.</p>
                <img src="im5.PNG">
                <p class="a"><i>Figure 50. Data Set Concatenation for EKGIN3</i></p>
                <h3 class="heading1">Running the RODM Load Function</h3>
                <p class="a">This topic describes running the RODM load function, plus considerations when<br>
                    running the load function, in the following order:</p>
                    <p class="a">
                        <ul>
                            <li>The load function as an initialization method</li>
                            <li>Invoking the load function as a batch job</li>
                            <li> Running the load function from a module</li>
                            <li>Considerations when running the load function</li>
                        </ul>
                    </p>
                    <p class="a">You can run the RODM load function by running it as an initialization method, as<br>
                        a job, or as a module call. A RODM load function job can parse the data model,<br>
                        load the data model into the RODM data cache, or verify the data model.</p>
                    <p class="a">A good practice is to parse your data model definition before you attempt to load<br>
                        it. This can reduce the number of errors that occur during the load. This practice<br>
                        enables you to identify and correct errors in your load function input statement<br>
                        syntax prior to loading these definitions into your RODM data cache.</p>
                    <h4 class="heading">The Load Function as an Initialization Method</h4>
                   <p class="a"> Use the initialization method provided with the NetView program or you can<br>
write one. In either case, before the initialization method can be triggered, an<br>
object with the name of the method must be created in the EKG_Method class by<br>
the user or by the RODM load function.</p>
<p class="a">The initialization method that is supplied by the NetView program has two parts:</p>
<h4 class="heading">EKGLISLM</h4>
<p class="b">Loads the methods defined in the method name table identified by the<br>
EKGIN2 DD statement; loads the class structure definitions in the<br>
sequential data set or concatenation of sequential data sets identified by<br>
the EKGIN1 DD statement; and then triggers EKGLIILM.</p>
<h4 class="heading">EKGLIILM</h4>
<p class="b">Loads the object definitions in the sequential data set or concatenation of<br>
sequential data sets identified by the EKGIN3 DD statement.</p>
<p class="a">EKGLISLM and EKGLIILM run as methods in the RODM address space. These<br>
methods use the environment that RODM passes to them and operate as<br>
object-independent methods.</p>
<p class="a"><b class="bold">Cold Start (Initialization):</b> To initialize RODM and load the data cache from a<br>
cold start, you specify the name of the initialization method using the INIT=<br>
parameter of the RODM start up command. You run a program (EKGTC000),<br>
which triggers EKGLISLM, the load function initialization method, which in turn<br>
triggers EKGLIILM. Because a cold start requires a structure load, you do not<br>
specify INIT=EKGLIILM as a parameter of the RODM start up command for a<br>
cold start.</p><br>
<p class="a">The NetView program provides an example of a RODM startup procedure named<br>
EKGXRODM. This procedure performs an initialization load, but before running<br>
this start up procedure, make the following modifications to the start up procedure<br>
JCL:</p><br>
<p class="a">
    <ul>
        <li>v Change the specification of USER.METHODS for DSN= parameter on the<br>
            STEPLIB DD statement to reflect the name of the partitioned data set containing<br>
            your user-written methods. If there are none, comment out or delete this<br>
            statement.</li>
        <li>Ensure that EKGIN1 and EKGIN3 DD statements identify your class structure<br>
            and object definitions. The supplied procedure identifies data sets that contain<br>
            examples of how to code the definitions.</li>
        <li>v Remove the comment delimiters from all other JCL statements.</li>
    </ul>
</p>
<p class="a">You run the procedure by entering:<br>
    S EKGXRODM,TYPE=C,INIT=EKGLISLM</p>
<p class="a">In this example: 
    <ul><li>EKGXRODM is the procedure name.</li>
     <li> TYPE=C specifies a cold start operation. </li>
     <li>INIT=EKGLISLM specifies the name of the method to trigger.</li></ul></p>
     <p class="a"><b class="bold">Warm Start:</b> Although you can use EKGLISLM to load the class structure and<br>
        object definitions into the data cache at warm start, just like a cold start, you<br>
        normally specify EKGLIILM for the INIT= parameter to load only the object<br>
        definitions. Usually you are warm starting to change the network configuration or<br>
        as a result of an error.</p>
    <p class="a">NetView provides an example RODM start up procedure named EKGXRODM. Use<br>
        it to perform the object definition load. Before running the procedure, make the<br>
        following modifications to the sample procedure's JCL to load only the object<br>
        definitions:</p>
    <p class="a">
        <ul>
            <li>Comment out the C Library in the STEPLIB DD, if necessary, as described in the<br>
                notes in the procedure heading. </li>
<li>v Ensure that the EKGIN3 DD statement identifies your definitions. The supplied<br>
    procedure identifies the data set that contains examples of how to code the<br>
    object definitions.</li>
<li>Remove the comment delimiters from only the EKGLUTB, EKGPRINT and<br>
    EKGIN3 DD statements.</li>        </ul><br></p>
    <p class="a">Run the procedure by entering:<br>
S EKGXRODM,TYPE=W,INIT=EKGLIILM
where:
<ul>
    <li>EKGXRODM is the procedure name</li>
    <li>TYPE=W specifies a warm start operation</li>
    <li>INIT=EKGLIILM specifies the name of the method to trigger.</li>
</ul>
    </p>
    <h4 class="heading">Invoking the Load Function As a Batch Job</h4>
    <p class="a">You can run the RODM load function as a batch job. The RODM load function<br>
        uses the verified user ID of the job submitter as the User_appl_ID to connect to<br>
        RODM. The verified user ID is obtained from the system authorization facility. <br>
        This user ID must have a minimum RODM authorization level of 3 or 5,<br>
        depending on the load function statements used. See “Authorization and<br>
        Authorization Levels” on page 252 for the required authorization level.</p>
    <p class="a">Your job can load:
        <ul>
            <li>The object definitions only</li>
            <li>The methods and class structure definitions</li>
            <li>The methods and all the definitions</li>
        </ul>
    </p>
    <p class="a">The NetView program supplies a sample job and procedure to run the RODM load<br>
        function as a batch job. The sample job EKGLLOAD calls the procedure<br>
        EKGLOADP and passes the parameters you specify. The following sections show<br>
        how to update the EKGLLOAD sample job for each of the three ways you can load<br>
        RODM.</p>
    <p class="a">Loading Object Definitions Only: Copy the sample job EKGLLOAD and update<br>
        it to load object definitions into RODM. Update the system level qualifier in the<br>
        EKGLOADP procedure if you do not use NETVIEW.V6R2M1 as the high-level<br>
        qualifiers of the RODM data sets on your system. The following steps give<br>
        example values for the parameters passed by the EKGLLOAD job to the<br>
        EKGLOADP procedure. Provide your own values for each parameter.<br>
         1. Update the JOB statement with your accounting information.<br>
        2. Fill in RODMNAME with the name of your RODM.<br>
        3. Fill in EKGIN3 with the name of the data set that contains your object<br>
        definitions<br>
        4. Ensure RODM is running and submit the EKGLLOAD job</p>
        <p class="a">Figure 51 shows the lines in EKGLLOAD updated with example values.</p>
        <img src="im6.PNG">
        <p class="a"><i>Figure 51. Object Load Batch Job Using EKGLLOAD Sample</i></p>
        <p class="a"><b class="bold">Loading Method Names and Class Structure:</b> Copy the sample job EKGLLOAD<br>
            and update it to load class and method definitions into RODM. Update the system<br>
            level qualifier in the EKGLOADP procedure if you do not use NETVIEW.V6R2M1<br>
            on your system. The following steps give example values for the parameters<br>
            passed by the EKGLLOAD job to the EKGLOADP procedure. Provide your own<br>
            values for each parameter:<br>
            1. Update the JOB statement with your accounting information.<br>
            2. Fill in RODMNAME with the name of your RODM.<br>
            3. Fill in EKGIN1 with the name of the data set that contains your class<br>
            definitions.<br>
            4. Specify LOAD=STRUCTURE for a class and method load.<br>
            5. Ensure RODM is running and submit the EKGLLOAD job.</p>
            <p class="a">Your methods are defined in the method table in NETVIEW.V6R2M1.CNMSAMP.<br>
                 You do not need to specify this data set name. Figure 52 shows the lines in<br>
                EKGLLOAD updated with example values.
                </p>
                <img src="im7.PNG">
                <p class="a"><i>Figure 52. Class and Method Load Batch Job Using EKGLLOAD Sample</i></p>
                <p class="a"><b class="bold">Loading Method Names and All Definitions:</b> You have two options to load the<br>
                    classes, methods, and objects using the EKGLLOAD sample job:</p>
                <p class="a"><ul>
                    <li> Load the classes and methods first, following the steps in “Loading Method<br>
                        Names and Class Structure” and then load the objects, following the steps in<br>
                        “Loading Object Definitions Only” on page 250. </li>
                    <li>Put all of the class, method, and object definitions in a single data set and load<br>
                        that data set by following the steps in “Loading Object Definitions Only” on<br>
                        page 250.</li>
                   
                </ul></p>
        <p class="a">Instead of putting all of the definitions in a single data set, you can concatenate<br>
            separate data sets. This requires updating the EKGLOADP procedure, because the<br>
            EKGLLOAD job can pass only one data set as a parameter.</p>     
        <h4 class="heading">Calling the Load Function from a Module</h4>  
        <p class="a">To run the RODM load function from a module, call the appropriate entry point<br>
            for the language that you are using. The RODM load function uses the verified<br>
            user ID, associated with the calling program at execution time, as the<br>
            User_appl_ID to connect to RODM. The verified user ID is obtained from the<br>
            system authorization facility. This user ID must have a minimum RODM<br>
            authorization level of 3 or 5, depending on the load function statements used. See<br>
            “Authorization and Authorization Levels” on page 252 for the required<br>
            authorization level. If a listing is requested, the listing and other information are<br>
            written to the specified data set for use by the calling module.</p>  
        <p class="a">You must specify RMODE=24 when you link-edit the RODM load function<br>
            module.</p>   
            <p class="a"><b class="bold">From Modules Written in PL/I and C</b>User application programs written in PL/I<br>
                or C that call the RODM load function directly must call the EKGLJOB entry point.<br>
                The linkage to EKGLJOB must adhere to z/OS conventions as described in “z/OS<br>
                Linkage Conventions” on page 265. The RODM load function runs all load<br>
                functions in the user application program task control area environment.</p>
            <p class="a"><b class="bold">From Modules Not Written in PL/I or C:</b>User application programs not written<br>
                in PL/I or C that call the RODM load function directly must call the EKGLOTLM<br>
                entry point. The EKGLOTLM
                 entry point creates a task control area environment<br>
                in which all load functions are run. Use the same linking conventions as for<br>
                EKGLJOB. See “z/OS Linkage Conventions” on page 265.
                </p>
            <h4 class="heading">Considerations When Running the RODM Load Function</h4>
            <p class="a"><b class="bold">The RODM Load Function: </b>When running the RODM load function, you can run<br>
                only one RODM load function job per address space. Ensure that the PL/I runtime<br>
                libraries are installed or available prior to submitting or running a job. The RODM<br>
                load function sets the value of the EKG_StopMode field to 3 before disconnecting.<br>
                (Do not purge notification queues or subscriptions.) This value enables the RODM<br>
                load function to disconnect without purging any notification subscriptions,<br>
                notification queues, or notification methods that are created as the result of<br>
                methods triggered by the RODM load function.</p>
                <p class="a"><b class="bold">The RODM Program:</b>The RODM program must be running for<br>
                    OPERATION=LOAD and for OPERATION=VERIFY because the RODM load<br>
                    function issues a connect request to RODM to access the data cache. If RODM is<br>
                    not running, an error message is issued.</p>
                <p class="a">RODM does not need to be running for OPERATION=PARSE. With<br>
                    OPERATION=PARSE, the RODM load function reads the load function input files<br>
                    and parses them to find syntax errors. The RODM load function issues the connect<br>
                    function to RODM and queries the RODM version and release. Errors found in the<br>
                    connect and query function are logged in the Job log and RODM log. However,<br>
                     these errors are not considered as errors of the RODM load Parse operation. For<br>
                    more information about OPERATION=, see “OPERATION” on page 271.</p>
                <p class="a">Ensure that the name you use to run the RODM load function is the same as the<br>
                    name of the RODM program that is running. The specification for the NAME=<br>
                    parameter must equal the name of the running RODM program. For information<br>
                    about parameter NAME=, see “NAME” on page 270.</p>
                <p class="a"><b class="bold">Authorization and Authorization Levels:</b> The TSO ID and TSO password that<br>
                    you use to run the RODM load function and user application programs that run<br>
                    the RODM load function must be authorized by your system authorization facility<br>
                    to access RODM, unless the SEC_CLASS keyword is set to *TSTRODM in<br>
                    customization file EKGCUST.</p>
                <p class="a">The ID that runs the load function must have an authorization level of at least 3 or<br>
                    5, depending on the load function statements used. Table 23 on page 253 shows the<br>
                    load function statement, the statement type, the minimum authorization level, and<br>
                    a reference to additional information about the statement.
                    </p>
                <p class="a"><i>Table 23. Load Function Statements and Minimum Authorization Levels</i></p>
                <p class="a">
                    <table border="2">
                        <tr><th>Statement</th><th>Statement<br>
                            Type</th><th>Minimum<br>
                                Authorization Level</th><th>See Page</th></tr>
                    <tr><td>CREATE</td><td>High-level</td><td>3</td><td>277</td></tr>
                    <tr><td>DELETE</td><td>High-level</td><td>3</td><td>278</td></tr>
                    <tr><td>FORCE_HAS_NO_INSTANCE</td><td>Primitive</td><td>3</td><td>282</td></tr>
                    <tr><td>FORCE_NOT_A_CLASS</td><td>Primitive</td><td>5</td><td>283</td></tr>
                    <tr><td>HAS_FIELD</td><td>Primitive</td><td>5</td><td>283</td></tr>

                    <tr><td>HAS_INSTANCE</td><td>Primitive</td><td>3</td><td>285</td></tr>
                    <tr><td>HAS_NO_FIELD</td><td>Primitive</td><td>5</td><td>285</td></tr>
                    <tr><td>HAS_NO_INSTANCE</td><td>Primitive</td><td>3</td><td>286</td></tr>
                    <tr><td>HAS_NO_SUBFIELD</td><td>Primitive</td><td>5</td><td>286</td></tr>
                    <tr><td>HAS_PARENT</td><td>Primitive</td><td>5</td><td>287</td></tr>
                    <tr><td>HAS_PRV_FIELD</td><td>Primitive</td><td>5</td><td>287</td></tr>
                    <tr><td>HAS_SUBFIELD</td><td>Primitive</td><td>5</td><td>288</td></tr>
                    <tr><td>HAS_VALUE</td><td>Primitive</td><td>3</td><td>288</td></tr>
                    <tr><td>INHERITS</td><td>Primitive</td><td>3</td><td>289</td></tr>
                    <tr><td>INVOKED_WITH</td><td>Primitive</td><td>3</td><td>289</td></tr>
                    <tr><td>IS_LINKED_TO</td><td>Primitive</td><td>3</td><td>290</td></tr>
                    <tr><td>IS_NOT_LINKED_TO</td><td>Primitive</td><td>3</td><td>291</td></tr>
                    <tr><td>MANAGED OBJECT CLASS</td><td>High-level</td><td>5</td><td>275</td></tr>
                    <tr><td>NOT_A_CLASS</td><td>Primitive</td><td>5</td><td>292</td></tr>
                    <tr><td>SET</td><td>High-level</td><td>3</td><td>279</td></tr>
                    <tr><td>SUBFIELD_HAS_VALUE</td><td>Primitive</td><td>3</td><td>292</td></tr>
                    <tr><td>SUBFIELD_INHERITS</td><td>Primitive</td><td>3</td><td>293</td></tr>


                </table></p>
                <h3 class="heading1">Checking the Output Listings</h3>
                <p class="a">To understand the output listings, you must understand the format of the output<br>
                    messages and the contents of the output listing</p>
                <p class="a"><b class="bold">Note:</b>Refer to the NetView online help for a description of the messages issued<br>
                    by the RODM load function. All RODM load function messages start with EKG8.</p>
                <p class="a">Two output listings consisting of different types of information are created when<br>
                    you run the RODM load function. One listing is created by the RODM load<br>
                    function and is written to the data set specified by the EKGPRINT DD statement.<br>
                    The other is system-generated output and is directed to SYSOUT. If the EKGPRINT<br>
                    DD statement specifies SYSOUT as the output data set, the separate listings appear<br>
                    as one report.</p>
                <h4 class="heading">RODM Load Function Output Listing</h4>
                <p class="a">The listing created by the RODM load function contains the date, the name of the<br>
                    function with its current level, a list of the options used when the load function<br>
                    was run, load function input, actions taken by the function, echoed syntax when<br>
                    an error occurs, and messages including an END OF JOB message. See Figure 55<br>
                    on page 257 for an example of the load function output listing for an object load.</p>
                <p class="a">When displaying the contents of the data set identified by the EKGPRINT DD<br>
                    statement, ensure that the software and hardware used can do so in mixed case.<br>
                    RODM data is case sensitive, and to display the data in other than mixed case<br>
                    hinders your verification of the RODM load.</p>
                <p class="a">All syntax can be echoed, interleaved with messages, where appropriate, indicating<br>
                    the success or failure of the primitive that was performed, or only syntax errors<br>
                    can be echoed, with messages indicating where errors are detected. The<br>
                    LISTLEVEL parameter as described on page “LISTLEVEL” on page 269 defines<br>
                    which level of syntax echoing occurs.</p>
                    <h4 class="heading">RODM Load Function Output Format</h4>
                <p class="a">Formats differ slightly for the RODM load function output, depending on the<br>
                    following items:</p>
                    <p class="a">
                        <ul>
                            <li>Type of operation: PARSE, LOAD, or VERIFY</li>
                            <li>Type of load: STRUCTURE or INSTANCE</li>
                            <li>LISTLEVEL option: ERRORSYNTAX or ALLSYNTAX</li>
                        </ul>
                    </p>
                    <p class="a">For more information about these parameters, see “RODM Load Function<br>
                        Parameter Syntax” on page 269.</p>
                    <p class="a">Compare the following figures for format differences:
                        <ul>
                            <li>Figure 53 on page 255, a PARSE operation output example</li>
                            <li> Figure 54 on page 256, a structure load output example</li>
                            <li>Figure 55 on page 257, an object load output example</li>
                        </ul>
                    </p>
                    <img src="im8.PNG">
                    <p class="a"><i>Figure 53. Example of PARSE Operation Output to EKGPRINT</i></p>
                    <img src="im9.PNG">
                    <p class="a"><i>Figure 54. Example of Structure Load Output to EKGPRINT</i></p>
                    <img src="im10.PNG">
                    <p class="a"><i>Figure 55. Example of Object Load Output to EKGPRINT</i></p>
                    <hr class="hr">
                    <h2>Load Function Reference</h2>
                    <p class="a">This section contains additional reference information for the RODM load function.<br>
                        It describes the following: v Verify operation of the load function
                        <ul>
                            <li>Usage of data types</li>
                            <li>Null values for load function data types</li>
                            <li>RODM tables:</li>
                        </ul>
                       </p>
<p class="a"> – Control table—EKGCTABL<br>
    – Method name table <br>
    – Parameter mapping table<br>
<ul>
    <li>Required and optional data definition names</li>
    <li>z/OS linkage conventions for the load function</li>
    <li>Syntax for RODM load function: </li>
    – Parameters used to run the load function<br>
– High-level statements <br>
– Primitives<br>
 – Common syntactic elements<br>
</ul></p>
<h3 class="heading1">Understanding the Verify Operation</h3>
<p class="a">The verify operation parses the RODM load function input files and compares the<br>
    statements with the contents of the data cache. No changes are made to the data<br>
    cache. The verify operation parses both high-level load function statements and<br>
    load function primitive statements. The load function primitive statements are<br>
    easier to understand, so they are described first.</p>
<p class="a">Each load function primitive statement description in “Syntax and Processing Logic<br>
    for Load Function Primitives” on page 282 includes an explanation of the verify<br>
    operation logic for that statement. The verify operation logic describes how the<br>
    load function compares the statement to the contents of the data cache. If the<br>
    comparison is true, the load function issues a return code of zero. If the<br>
    comparison is not true, the load function returns an error message.</p>
<p class="a">For example, if you want to ensure that one class in the data cache is the parent of<br>
    another class, you can use the verify operation with the HAS_PARENT load<br>
    function primitive statement. The verify operation logic for the HAS_PARENT load<br>
    function primitive statement directs the load function to check if the specified child<br>
    class and parent class exist in the data cache. The load function then checks if the<br>
    MyPrimaryParentID field of the child class points to the parent class. RODM must<br>
    be running when you use the verify operation of the load function.</p>
<p class="a">The RODM load function processes high-level load function statements by first<br>
    converting them to load function primitive statements. The load function primitive<br>
    statements are then processed as in the previous example.</p>
<p class="a">For example, the following high-level load function statement can be processed by<br>
    the load function.</p>
    <img src="im11.PNG">
    <p class="a">When you run the verify operation, the load function converts the statement to<br>
        load function primitive statements. The first two lines of the statement are<br>
        converted to the following:</p>
    <p class="b">OP ClassA HAS_PARENT UniversalClass;</p>
    <p class="a">This load function primitive statement is processed as in the first example.</p>
    <p class="a">Each line of the field definition list is converted to one statement to create the field<br>
        and a second statement to assign the initial value if one is supplied. The first field<br>
        definition in this example is converted to the following:</p>
    <p class="b">OP ClassA HAS_FIELD (CHARVAR) Field_1;<br>
        OP ClassA..Field_1 HAS_VALUE (CHARVAR) ’abc’;
        </p>
    <p class="a">Each of the load function primitive statements is then processed as described in<br>
        “Syntax and Processing Logic for Load Function Primitives” on page 282.
        </p>
    <p class="a">When you use the verify operation with load function statements that specify<br>
        values for fields, be careful because values often change. Only test for a specific<br>
        value when you are interested in that value. In the high-level load function<br>
        statement example, the initial value of Field_1 caused the load function to generate<br>
        a statement to test Field_1 for the value abc. Remove the initial values from field<br>
        definitions before using the verify operation if all you need to test for is the<br>
        structure of the data cache.</p>
        <h3 class="heading1">Using CLASSID and OBJECTID Data Types</h3>
        <p class="a">The RODM load function enables you to specify the CLASSID and OBJECTID data<br>
            types for fields. However, the corresponding ClassID and ObjectID abstract data<br>
            types in RODM are reserved; you cannot create fields with these data types, except<br>
            within a SELFDEFINING variable.</p>
        <h4 class="heading">CLASSID</h4>
    <p class="a">If you create a field of type CLASSID using the RODM load function, the field is<br>
        created in the RODM data cache with the Integer abstract data type. The RODM<br>
        load function gets the class ID for the class name you specify and puts the class ID<br>
        value in the target field in the RODM data cache which must be of type Integer.</p>
<p class="a">When you assign a value of type CLASSID using the RODM load function, you<br>
    supply a class name, but be sure the class name specified already exists. If you<br>
    create a field of type CLASSID using the RODM load function, but do not assign<br>
    an initial value, the field is created with a null value.</p>
    <h4 class="heading">OBJECTID</h4>
<p class="a">If you create a field of type OBJECTID using the RODM load function, the field is<br>
    created in the RODM data cache with the AnonymousVar abstract data type. The<br>
    RODM load function gets the object ID for the object name you specify and puts<br>
    the object ID value in the target field in the RODM data cache which must be of<br>
    type AnonymousVar.</p>
<p class="a">When you assign a value of type OBJECTID using the RODM load function, you<br>
    supply a class name and an object name, but be sure the object name and class<br>
    name you specify already exist. If you create a field of type OBJECTID using the<br>
    RODM load function, but do not assign an initial value, the field is created with a<br>
    null value.</p>
    <h3 class="heading1">Null Values for RODM Load Function Data Types</h3>
<p class="a">You can specify null values for some of the data types used in RODM load<br>
    function primitives and RODM high-level load function statements. This enables<br>
    you to set the value of a field to its null value as defined by RODM. The following<br>
    list shows how to specify each null value:</p>
<img src="im12.PNG">
<img src="im13.PNG">
<h3 class="heading1">Control Table—EKGCTABL</h3>
<p class="a">You can modify the member names contained in this required control table called<br>
    EKGCTABL. This table is a member of the partitioned data set identified by the<br>
    EKGLUTB DD statement which is a required DD statement. RODM expects the<br>
    member name to remain EKGCTABL and to be contained in the data set identified<br>
    by the EKGLUTB DD statement.</p>
<p class="a">The EKGCTABL control table contains two entries:</p>
<h4 class="heading">PARAMETER_MAPPING_MEMBER</h4>
<p class="b">Specifies the name of the member of the partitioned data set identified by<br>
    the EKGLUTB DD statement that contains the parameter mapping table.
    </p>
    <h4 class="heading">INSTALL_METHOD_MEMBER</h4>
<p class="b">Specifies the name of the member of the partitioned data set identified by<br>
    the EKGIN2 DD statement that contains the method name table.</p>
<p class="a">Figure 56 shows an example control table. The column scale is inserted for<br>
    explanation purposes and is not part of the control table.</p>
<img src="im14.PNG">
<p class="a"><i>Figure 56. Sample Control Table EKGCTABL with Column Scale</i></p>
<p class="a">The required symbols PARAMETER_MAPPING_MEMBER and<br>
    INSTALL_METHOD_MEMBER must start in column 1. The member names,<br>
    EKGPTENU and EKGINMTB in this example, must start in column 41.<br>
    </p>
<h4 class="heading">Relationships to Other Tables and DD Names</h4>
<p class="a">Figure 57 on page 261 shows the relationship between the EKGCTABL control<br>
    table, the EKGPTENU parameter mapping table, the EKGINMTB method name<br>
    table, and the EKGLUTB and EKGIN2 DD names.</p>
<p class="a">In the figure, the job stream to verify the structure of a RODM named<br>
    RODMNAME has EKGLUTB and EKGIN2 DD statements. The EKGLUTB DD<br>
    statement identifies the CNMSAMP partitioned data set that contains the<br>
    EKGCTABL and EKGPTENU members. The EKGIN2 DD statement identifies the<br>
    CNMSAMP partitioned data set that contains the EKGINMTB member. RODM<br>
    uses the EKGCTABL control table to obtain the member names of the parameter<br>
    mapping table and method name table.</p>
<img src="im15.PNG">
<p class="a"><i>Figure 57. Relationship between EKGCTABL, EKGINMTB, EKGPTENU and JCL</i></p>
<h3 class="heading1">Method Name Table</h3>
<p class="a">The method name table contains the names of the methods you want installed by<br>
    the RODM load function. A sample file named EKGINMTB that contains only one<br>
    entry (EKGNOTF) is shipped in the samples library<br>
    NETVIEW.V6R2M1.CNMSAMP. You can either copy that file and make<br>
    modifications or create your own.</p>
<p class="a">You do not have to use the name of EKGINMTB for your method name table, but<br>
    if you use a different name you must modify the control table EKGCTABL because<br>
    in the control table that is supplied by IBM the member name specified for the<br>
    method name table is EKGINMTB. For more information about control table<br>
    EKGCTABL, see “Control Table—EKGCTABL” on page 260.</p>
<p class="a">Figure 58 on page 262 shows a method name table (EKGINMTB) that declares two<br>
    user-written methods and seven methods that are supplied with the NetView<br>
    program. The column scale is inserted for explanation purposes and is not part of<br>
    the method name table.</p>
    <img src="im16.PNG">
    <p class="a"><i>Figure 58. Method Name Table Format with Column Scale</i></p>
    <p class="a">Each entry in a method name table consists of one row. Columns 1–8 contain the<br>
        name of the method, and columns 11–80 can optionally contain a comment, such<br>
        as the type of method.</p>
    <p class="a">To bypass the RODM method name table load, replace EKGINMTB with *NONE<br>
        in control table EKGCTABL as shown in Figure 59. The column scale is inserted for<br>
        explanation purposes and is not part of the method name table.</p>
    <img src="im17.PNG">
    <p class="a"><i>Figure 59. Sample Control Table EKGCTABL with Column Scale</i></p>
    <h4 class="heading">Associated DD Statements and Control Table</h4>
    <p class="a">The DD statement that declares the partitioned data set containing the method<br>
        name table as one of its members is labeled EKGIN2. The member name for the<br>
        method name table is in control table EKGCTABL which is in the partitioned data<br>
        set identified by the DD statement labeled EKGLUTB. See Figure 57 on page 261<br>
        for a pictorial of this relationship.</p>
        <h3 class="heading1">Parameter Mapping Table</h3>
        <p class="a">When you run the RODM load function, you must supply parameters, such as<br>
            NAME, OPERATION, CODEPAGE, and LOAD. According to JCL conventions,<br>
            these parameters go in parentheses on the PARM= part of the EXEC statement.<br>
            They take the form:</p>
        <p class="a"><b class="bold">PARM=</b><i>('keyword1=keyword_value1,keyword2=keyword_value2,...')</i></p>
        <p class="a">The parameter mapping table is a fixed-block table with an LRECL of 80. The table<br>
            enables string substitutions to be used for the syntax known by the RODM load<br>
            function (internal syntax). These string substitutions can be abbreviations, a<br>
            mapping to a national language, or both. This enables the RODM load function to<br>
            use other syntax formats.
            </p>
        <p class="a">The parameter mapping table (EKGPTENU) is a member of the partitioned data<br>
            set identified by the EKGLUTB DD statement. The EKGCTABL control block<br>
            contains the member name of the parameter mapping table. See Figure 57 on page<br>
            261 for a pictorial of this relationship.</p>
        <p class="a">Table EKGPTENU has a one-to-one relationship between the internal syntax in<br>
            columns 1–30 and the substitution string in columns 31–80. See “RODM Load</p>
        <p class="a">Function Parameter Syntax” on page 269 for information about the load function<br>
            parameter data (internal syntax) in columns 1–30.</p>
        <p class="a">The syntax rules are:<br>
            <ul>
                <li> Internal<i> keyword entries</i> must start in column 1 and each related substitution<br>
                    string entry must start in column 31.</li>
                <li> Internal<i>keyword values</i> must start in column 2 and each related substitution<br>
                    string value must start in column 32.</li>
                <li>The internal <i>keyword default</i> value must start in column 3 and the substitution<br>
                    string default value must start in column 33.</li>
                    <li>For each keyword, the keyword entry is followed by the value entries for that<br>
                        keyword, which are in turn followed by the default value entry for that<br>
                        keyword.</li>
            </ul>
        </p>
        <p class="a">Figure 60 documents the format of this table and shows examples of abbreviation<br>
            substitution strings. The column scale is inserted for explanation purposes and is<br>
            not part of the parameter mapping table</p>
        <img src="im18.PNG">
        <p class="a"><i>Figure 60. Sample Parameter Table EKGPTENU with Column Scale</i></p>
        <p class="a">You can modify an existing mapping table or create a new table. A sample load<br>
            function parameter mapping table can be found in member EKGPTENU of data set<br>
            CNMSAMP in the samples library supplied with RODM. Copy the sample and<br>
            make any updates to the copy. If you change the name of the parameter table, be<br>
            sure to update the EKGCTABL control table.</p>
        <h4 class="heading">RODM Data Definition (DD) Statements</h4>
        <p class="a">The DD statements that are used to run the load function declare the data sets.<br>
            Ensure that the data sets appropriate to the type of load you are running are<br>
            present. Ensure that the contents of the data sets are valid.</p>
        <p class="a">You can change DD names to match your needs by using the DD list structure,<br>
            which you can pass to RODM using a parameter list when the load function is<br>
            run. The DD list structure is described in “z/OS Linkage Conventions” on page<br>
            265.</p>
            <h4 class="heading">STEPLIB (Required If You Do Not Use LNKLIST)</h4>
            <p class="b">The data set identified as STEPLIB must be a partitioned data set that<br>
                contains the RODM load function code. STEPLIB is a required DD<br>
                statement when the RODM load function code is not in the z/OS<br>
                LNKLIST. Another DD statement must be concatenated to the STEPLIB DD<br>
                statement that identifies the Language Environment®
                runtime library. The<br>
                format of STEPLIB is the standard DCB (data control block) format for any<br>
                link-edited data set.</p>
            <h4 class="heading">EKGLANG (Required)</h4>
            <p class="b">The EKGLANG DD statement identifies the partitioned data set that<br>
                contains the message file for the RODM load function.</p>
                <h4 class="heading">EKGLUTB (Required)</h4>
                <p class="b">The EKGLUTB data definition identifies the partitioned data set that<br>
                    contains the EKGCTABL control table file as one of its members. This<br>
                    required control table contains the member name of the parameter<br>
                    mapping table and the member name of the method name table. For more<br>
                    information about modifying the EKGCTABL control table and its<br>
                    relationship with the parameter mapping table and the method name table,<br>
                    see “Control Table—EKGCTABL” on page 260.</p>
                <p class="b">The data control block for the DD statement labeled EKGLUTB specifies<br>
                    LRECL=80 and RECFM=FB for the data set. The block size must be a multiple<br>
                    of 80.</p>
                <h4 class="heading">EKGPRINT (Required)</h4>
                <p class="b">The EKGPRINT data definition identifies the data set containing the<br>
                    RODM load function output listing. This listing contains the load function<br>
                    input, echoed syntax, a report of primitive success or failure, messages and<br>
                    codes, and other information.</p>
                <p class="b">You can direct the print to SYSOUT, to a sequential file, or to a member of<br>
                    a partitioned data set. The data set or file must specify LRECL=80 and<br>
                    RECFM=FB. The block size must be a multiple of 80.</p>
                <h4 class="heading">EKGIN1 (Required for Class Structure Definition)</h4>
                <p class="b">EKGIN1 identifies the sequential data set or concatenation of sequential<br>
                    data sets that contain the class structure definitions. The data sets that<br>
                    define the class structure must be sequential data sets with a data control<br>
                    block that specifies LRECL=80 and RECFM=FB. The block size must be a<br>
                    multiple of 80. The class structure definitions which represent the GMFHS<br>
                    data model are contained in member DUIFSTRC of the CNMSAMP data<br>
                    set in the samples library.
                    </p>
                <h4 class="heading">EKGIN2 (Required for Class Structure Definition)</h4>
                <p class="b">EKGIN2 identifies the partitioned data set that contains the method name<br>
                    table file as one of its members. EKGIN2 must be a partitioned data set<br>
                    with a data control block that specifies LRECL=80 and RECFM=FB. The block<br>
                    size must be a multiple of 80. The method name table that is supplied by<br>
                    IBM which has one entry of EKGNOTF (notify method) is contained in<br>
                    member EKGINMTB of the CNMSAMP data set in the samples library. </p>
                    <h4 class="heading">EKGIN3 (Required for Object Definition)</h4>
                <p class="b">EKGIN3 identifies the sequential data set or concatenation of sequential<br>
                    data sets that contain the object definitions. You create these definitions to<br>
                    define your network. The data control block of each of the data sets<br>
                    concatenated as EKGIN3 must specify LRECL=80 and RECFM=FB. The block<br>
                    size must be a multiple of 80. The object definitions which define the<br>
                    network described in Chapter 2, “Defining Your Network to GMFHS,” on<br>
                    page 15 are contained in member DUIFSNET of the CNMSAMP data set in<br>
                    the samples library as an example.</p>
                    <h3 class="heading">Data Definitions Necessary for Initialization</h3>
                    <p class="a">If you are running an initialization method, either during a cold start or a warm<br>
                        start of RODM, you need data sets for the following data definition names:</p>
                        <p class="b">
                            EKGIN1<br>
EKGIN2<br>
EKGIN3<br>
EKGLANG<br>
EKGPRINT<br>
EKGLUTB<br>
                        </p>
                        <h3 class="heading">Data Definitions Necessary for Structure Load Only</h3>
                        <p class="a">When running the RODM load function either through job posting or through a<br>
                            module call to load only the class structure and install methods, you need data sets<br>
                            for the following data definition names:</p>
                            <p class="b">
                                EKGIN1<br>
EKGIN2<br>
EKGLANG<br>
EKGPRINT<br>
EKGLUTB<br>
                            </p>
                            <h3 class="heading">Data Definitions Necessary for Object Load Only</h3>
                            <p class="a">
                                When running the RODM load function either through job posting or through a<br>
module call to load only the object definitions, you need data sets for the following<br>
data definition names:
                            </p>
                            <p class="b">EKGIN3<br>
                                EKGLANG<br>
                                EKGPRINT<br>
                                EKGLUTB</p>
                            <h3 class="heading1">z/OS Linkage Conventions</h3>
                            <p class="a">Figure 61 on page 266 shows the z/OS linkage requirements for running the<br>
                                RODM load function by means of a module call to EKGLJOB.</p>
                            <p class="a">Register 1 points to the parameter list, which contains up to three parameter<br>
                                addresses. The first parameter address points to a <i>parameter structure</i> that you use<br>
                                to specify the RODM load function parameters. The second parameter address is<br>
                                optional unless the third parameter address is supplied. If it is supplied, it points<br>
                                to a DD <i>list structure</i> that you use to change the default RODM load function DD<br>
                                names. The third parameter address is optional. If it is supplied, it points to the<br>
                                <i>access block </i>that was used to connect to RODM. The last address in this parameter<br>
                                list must have the high-order bit set ON.
                                </p>
                                <img src="im19.PNG">
                                <p class="a"><i>Figure 61. z/OS Linkage Conventions Required for Module Call to EKGLJOB</i></p>
                                <h4 class="heading">Parameter Structure</h4>
                                <p class="a">The parameters passed to the load function are the same as the ones specified in<br>
                                    the JCL except that you must provide the length of the parameter. The only<br>
                                    required parameter is NAME; all of the parameters that are not specified, default<br>
                                    to the values specified in the parameter mapping table.<br>
                                    </p>
                                <p class="a">The NAME parameter is ignored if the access block is specified.</p>
                                <p class="a">The parameter structure consists of a 2-byte fixed field followed by a character<br>
                                    field. The fixed field must contain the length of the following character field. The<br>
                                    restrictions on JCL when running the load function require that the character field<br>
                                    to be no more than 100 bytes in length. The character field can contain any valid<br>
                                    combination of input parameter values.
                                    </p>
                                <p class="a">The following is an example of the parameter structure in hextype format<br>
                                    (hexadecimal representation in the first line, EBCDIC in the second):<br>
                                    001CD5C1D4C57EC5D2C7E7D9D6C4D46BD3D6C1C47EE2E3D9E4C3E3E4D9C5</p>
                                <p class="b">N A M E = E K G X R O D M , L O A D = S T R U C T U R E</p>
                                <p class="a">This parameter specifies that the character field has a length of X'1C' bytes. The<br>
                                    character field contains the required NAME parameter and the<br>
                                    LOAD=STRUCTURE parameter. The remaining load function parameters will<br>
                                    default to the default values specified in the parameter mapping table.</p>
                                <h4 class="heading">DD List Structure</h4>
                                <p class="a">The DD list structure, if specified, consists of a two-byte fixed field followed by a<br>
                                    character field with no maximum length restriction, although the length of the<br>
                                    character field must be a multiple of 16. The DD list structure is used to specify<br>
                                    DD names only, not data set names or member names.</p>
                                <p class="a">The character field consists of an array of DD name pairs in which each element is<br>
                                    16 (X'10') bytes in length. The first eight bytes is the default or old DD name used<br>
                                    in the RODM load function, and the second eight bytes is the new DD name to be<br>
                                    used in the RODM load function. This array of DD name pairs can be in any order. <br>
                                    If no new DD names are provided, the default required DD names specified in<br>
                                    “RODM Data Definition (DD) Statements” on page 264 are used.</p>
                                <p class="a">The following is an example of the DD list structure in hextype format<br>
                                    (hexadecimal representation in the first line, EBCDIC in the second):<br>
                                    0020C5D2C7C9D5F14040E2E3D9E4C3E34040C5D2C7C9D5F34040D6C2D1C5C3E34040</p>
                                <p class="b">E K G I N 1 &nbsp; S T R U C T  &nbsp;  E K G I N 3 &nbsp;   O B J E C T
                                </p>
                                <p class="a">This parameter specifies that there are two DD name pairs and that the RODM<br>
                                    load function is to use the new DD name STRUCT instead of EKGIN1 and the new<br>
                                    DD name OBJECT instead of EKGIN3.</p>
                                <h4 class="heading">Access Block</h4>
                                <p class="a">The access block, if specified, is the access block that the user application used<br>
                                    when it connected to RODM. This allows a user application that is already<br>
                                    connected to RODM to use the RODM load function without first disconnecting<br>
                                    from RODM.</p>
                                <p class="a">If the access block parameter is specified, the DD list structure must also be<br>
                                    specified. However, if you do not want to change the DD names, you can specify a<br>
                                    null string.</p>
                                    <h4 class="heading">Calling the RODM Load Function</h4>
                                <p class="a">When you call the RODM load function, follow the linkage convention shown in<br>
                                    Figure 61 on page 266. The RODM load function linking convention follows a<br>
                                    standard z/OS approach. Use the ASM and INTER options when you define the<br>
                                    linkage of your modules to the RODM load function. Refer to Figure 62 on page<br>
                                    268 and locate the statement:</p>
                                <p class="a">DCL &nbsp;EKGLJOB &nbsp;&nbsp;&nbsp;OPTIONS(ASM INTER) ENTRY EXTERNAL;</p>
                                <p class="a">Figure 62 on page 268 is an example of how to call the RODM load function from<br>
                                    a PL/I program.</p>
                                    <img src="im20.PNG">
                                    <p class="a"><i>Figure 62. Calling the RODM Load Function from a PL/I Program</i></p>
                                <h3 class="heading1">RODM Load Function Parameter Syntax</h3>
                                <p class="a">The following are descriptions and syntax for RODM load function parameters in<br>
                                    alphabetical order. </p>
                                <p class="a">The syntax is shown in syntax diagrams.</p>
                                <h4 class="heading">CODEPAGE<br>
                                    Description</h4>
                                <p class="a">The code page for input scanning</p>
                                <h4 class="heading">Syntax</h4>
                                <h4 class="heading">CODEPAGE</h4>
                                <img src="im21.PNG">
                                <h4 class="heading">Usage Notes</h4>
                                <p class="a">To indicate code page 500 (U.S. English) for input scanning, you code:<br>
                                    CODEPAGE=EKGCP500</p>
                                <p class="a"><b class="bold">Note: </b>RODM load function supports only code page 500.</p>
                                <h4 class="heading">LISTLEVEL<br>
                                    Description</h4>
                                <p class="a">The level of the listing to generate. You can list only the syntax that is in error or<br>
                                    list all syntax used as input to the RODM load function.</p>
                                    <h4 class="heading">Syntax</h4>
                                <p class="a">LISTLEVEL</p>
                                <img src="im22.PNG">
                                <h4 class="heading">Usage Notes</h4>
                                <p class="a">When you specify:</p>
                                <h4 class="heading">LISTLEVEL=ALLSYNTAX</h4>
                                <p class="b">All syntax, including generated primitive statements, is listed with<br>
                                    messages indicating the success or failure of the high-level statements and<br>
                                    primitives that were performed interleaved where appropriate.</p>
                                    <h4 class="heading">LISTLEVEL=ERRORSYNTAX</h4>
                                <p class="b">Only the statements in error, <i>excluding primitive statements generated from<br>
                                    high-level statements,</i> are listed with their error messages. Error messages for<br>
                                    generated primitive statements appear after their associated high-level<br>
                                    statement. <i>The generated primitive statement that caused the error is not listed.</i></p>
                                <h4 class="heading">LOAD<br>
                                    Description</h4>
                                    <p class="a">The type of load. A structure load or an object load.</p>
                                    <h4 class="heading">Syntax</h4>
                                    <h4 class="heading">LOAD</h4>
                                    <img src="im23.PNG">
                                    <h4 class="heading">Usage Notes</h4>
                                    <p class="a">When you specify:</p>
                                    <h4 class="heading">LOAD=STRUCTURE</h4>
                                    <p class="b">Only the input statements from the data sets identified by the EKGIN1 and<br>
                                        EKGIN2 data definition statements are used. Used for structure load.</p>
                                    <h4 class="heading">LOAD=INSTANCE</h4>
                                    <p class="b">Only the input statements from the data sets identified by the EKGIN3<br>
                                        data definition statement are used. Used for object load.</p>
                                    <p class="a">You can also use the LOAD=STRUCTURE specification to load object definitions as<br>
                                        well as class structure definitions. Concatenate the data sets that contain the object<br>
                                        definitions, normally identified by the EKGIN3 DD statement, to the EKGIN1 DD<br>
                                        statement.</p>
                                    <p class="a">You can also include class structure definition with object definitions when<br>
                                        specifying LOAD=INSTANCE. Using concatenation of data sets, arrange the JCL<br>
                                        statements for the EKGIN3 DD so that the class structure definitions, usually<br>
                                        identified by the EKGIN1 DD, are processed first with the object definitions<br>
                                        following.</p>
                                    <h4 class="heading">NAME<br>
                                        Description</h4>
                                        <p class="b">The name of the RODM on which the load is to be performed. This is a required<br>
                                            parameter for structure loads and object loads.</p>
                                    <h4 class="heading">Syntax</h4>
                                    <h4 class="heading">NAME</h4>
                                    <img src="im24.PNG">
                                    <h4 class="heading">Usage Notes</h4>
                                    <p class="a">To specify a RODM name of MYRODM code: NAME=MYRODM</p>
                                    <p class="a">The NAME parameter is required for load and verify operations. If you specify<br>
                                        NAME for a parse operation, the RODM load function connects to the named<br>
                                        RODM, but this is not required.</p>
                                    <p class="a">The NAME parameter is not required for an initialization method load. Because a<br>
                                        particular RODM has run the RODM load function, the RODM name is known by<br>
                                        the load function</p>
                                    <h4 class="heading">OPERATION<br>
                                        Description</h4>
                                    <p class="a">The operation the RODM load function is to perform. The operation parameter can<br>
                                        specify that the RODM load function parse the load function input statement<br>
                                        syntax for validity, load the RODM data cache, or verify that defined contents exist<br>
                                        prior to performing another operation.</p>
                                    <h4 class="heading">Syntax</h4>
                                    <h4 class="heading">OPERATION</h4>
                                    <img src="im25.PNG">
                                    <h4 class="heading">Usage Notes</h4>
                                    <p class="a">You code:</p>
                                    <h4 class="heading">OPERATION=PARSE</h4>
                                    <p class="b">To parse the syntax of the data sets that contain your RODM load function<br>
                                        input parameters. RODM does not need to be running for<br>
                                        OPERATION=PARSE. With OPERATION=PARSE, the RODM load function<br>
                                        reads the load function input files and parses them to find syntax errors.<br>
                                        The RODM load function issues the connect function to RODM and<br>
                                        queries the RODM version and release. Any errors found in the connect<br>
                                        and query function are logged in the Job log and RODM log. However,<br>
                                         these errors are not considered as errors of the RODM load PARSE<br>
                                        operation.
                                        </p>
                                    <h4 class="heading">OPERATION=LOAD</h4>
                                    <p class="b">To parse the input statements and then load the data cache.</p>
                                    <h4 class="heading">OPERATION=VERIFY</h4>
                                    <p class="b">To parse and verify the contents of the RODM data cache.
                                    </p>
                                    <p class="a">Neither PARSE nor VERIFY performs the LOAD operation.</p>
                                    <p class="a">If you want to assign values to objects and wish to see which of the objects<br>
                                        actually exist instead of having them fail, use the VERIFY operation. For more<br>
                                        information about VERIFY, see “Understanding the Verify Operation” on page 258.</p>
                                    <p class="a">If LOAD=STRUCTURE, the input statements from the data sets identified by the DD<br>
                                        labeled EKGIN1 is parsed, but the data identified by the DD labeled EKGIN2 is<br>
                                        not. If LOAD=INSTANCE, only the input statements from the data sets identified by<br>
                                        the DD labeled EKGIN3 are parsed. This occurs for LOAD, PARSE, or VERIFY<br>
                                        operations.</p>
                                    <h4 class="heading">ROUTECODE<br>
                                        Description</h4>
                                    <p class="a">Defines the route code to be used when the loader issues messages to a console by<br>
                                        way of the WTO or WTOR macros. Valid values are in the range 1 – 128. The<br>
                                        default value is 1.</p>
                                    <p class="a">Messages that can be issued before this parameter is processed will use the default<br>
                                        route code 1, regardless of the value set here.
                                        </p>
                                    <h4 class="heading">Syntax</h4>
                                    <h4 class="heading">ROUTECODE</h4>
                                    <img src="im26.PNG">
                                    <h4 class="heading">SEVERITY<br>
                                        Description</h4>
                                    <p class="a">The way that the application is to treat an error (return code 8) in the processing of<br>
                                        a class structure definition or an object definition: as an error (return code 8) or as<br>
                                        a warning (return code 4).</p>
                                    <p class="a">For SEVERITY=ERROR, when the RODM load function encounters an error in a<br>
                                        load function input statement, it ends processing at that statement and issues a<br>
                                        return code of 8. For SEVERITY=WARNING, when the RODM load function<br>
                                        encounters an error in a load function input statement, it continues processing and<br>
                                        issues a return code of 4 upon completion.</p>
                                    <h4 class="heading">Syntax</h4>
                                    <h4 class="heading">SEVERITY</h4>
                                    <img src="im27.PNG">
                                    <h4 class="heading">Usage Notes</h4>
                                    <p class="a">If the application is to treat an error in the processing of a class structure definition<br>
                                        or an object definition as an error, you code: SEVERITY=ERROR</p>
                                    <p class="a">If the application is to treat an error in the processing of a class structure definition<br>
                                        or an object definition as a warning, you code: SEVERITY=WARNING</p>
                                    <p class="a">Use the WARNING option when you are parsing the syntax; use the ERROR<br>
                                        option when you are loading.
                                        </p>
                                    <h3 class="heading1">Coding RODM High-Level Load Function Statements</h3>
                                    <p class="a">This topic of the reference section describes how to code RODM high-level load<br>
                                        function statements. It provides the syntax and associated rules for high-level load<br>
                                        function statements.</p>
                                    <p class="a">The syntax is shown in syntax diagrams.</p>
                                    <h4 class="heading">Syntax Rules for High-Level Load Function Statements</h4>
                                    <p class="a">This topic addresses syntax rules that apply to RODM high-level load function<br>
                                        statements.</p>
                                    <p class="a"><b class="bold">Input Columns:</b> The RODM load function reads all columns of an input record as<br>
                                        data. Do not use columns 73 to 80 for sequence or line numbers. You can use<br>
                                        sequence or line numbers if you mark them as comments using the comment (--)<br>
                                        characters.</p>
                                    <p class="a"><b class="bold">Delimiters: </b>Table 24 describes valid syntax delimiters for RODM high-level load<br>
                                        function statements.</p>
                                    <p class="a"><i>Table 24. Syntax Delimiters for RODM High-Level Load Function Statements</i></p>
                                    <p class="a"><table border="2">
                                        <tr><th>Delimiter</th><th>Function</th></tr>
                                        <tr><td>' ' </td><td>Used to enclose a character string.</td></tr>
                                        <tr><td>X'0E' (Shift-out)</td><td>Marks the start of a DBCS mixed string data type</td></tr>
                                        <tr><td>X'0F' (Shift-in)</td><td>Marks the end of a DBCS mixed string data type</td></tr>
                                        <tr><td>-- (two hyphens)</td><td>Marks the beginning or end of a comment</td></tr>

                                    </table></p>
                                    <p class="a">The RODM load function allows free-form syntax. Spaces can be used to improve<br>
                                        the readability of your load function input data because the RODM load function<br>
                                        allows one or more spaces between parts of a RODM high-level load function<br>
                                        statement. For example, the following MANAGED OBJECT CLASS high-level load<br>
                                        function statement is a valid use of spaces to improve readability:</p>
                                    <img src="im28.PNG">
                                    <p class="a"><b class="bold">Quoted Strings:</b> A quoted string must begin and end on the same line. To create<br>
                                        a string longer than a single line, break it into separately quoted parts on multiple<br>
                                        lines. Multiple parts are concatenated by the RODM load function. For example,<br>
                                        the following two lines results in a single quoted string:<br>
                                        INIT(’ This is the first line of two lines ’<br>
                                        ’ that results in one quoted string ’ );<br>
                                        </p>
                                    <p class="a">A quotation mark contained within quotation marks is represented by two single<br>
                                        quotation marks, for example:<br>
                                        INIT(’This is ’’ a quote ’’ within a quote. ’);</p>
                                    <p class="a">Quotation marks are used to enclose the entire string, including any keywords or<br>
                                        separators as a portion of the string. For example:<br>
                                        INIT(’ Create the "MANAGED OBJECT CLASS" now ’);<br>
                                        </p>
                                        <p class="a"><b class="bold">Double-Byte Character Strings:</b> All data values between a X'0E' shift-out<br>
                                            character and a X'0F' shift-in character are treated by the RODM load function as<br>
                                            double-byte character string (DBCS) data. This means that any hexadecimal codes<br>
                                            that normally denote delimiters are treated as data within the double-byte<br>
                                            character string. The valid double-byte characters are the same as those for the<br>
                                            GraphicVar data type; see “GraphicVar” on page 227.</p>
                                        <p class="a"><b class="bold">Field Definition Lists: </b>When specifying a field definition list with the ATTRLIST<br>
                                            or MODLIST keyword, separate each member of the list with a comma and end<br>
                                            the list with a semicolon. Otherwise, the RODM load function treats each member<br>
                                            of the list as a separate statement.</p>
                                        <p class="a">Enabled data types and data type values for high-level statements are all those<br>
                                            enabled by RODM. For more information about these data types, see “Abstract<br>
                                            Data Type Reference” on page 219. For a list of these data type values and a syntax<br>
                                            diagram of the typed_value load function common syntactic element, see<br>
                                            “typed_value” on page 303</p>
                                        <p class="a"><b class="bold">Comments: </b>Comments are delimited by two hyphens (--) at the beginning and at<br>
                                            the end. An example is:<br>
                                             -- This is a comment --</p>
                                        <p class="a">If the end of comment delimiter is not specified, the end of the comment is<br>
                                            assumed to be at the end of the input line. The RODM load function ignores all<br>
                                            text between comment delimiters.<br>
                                            </p>
                                        <h4 class="heading">Syntax for High-Level Load Function Statements</h4>
                                        <p class="a">This is a syntax reference for your use in coding the RODM high-level load<br>
                                            function statements for the data model definition to be created in your RODM data<br>
                                            cache. Each RODM high-level load function statement has a description containing<br>
                                            the name, purpose, external syntax, parameter descriptions, and an example of use.</p>
                                        <p class="a"><b class="bold">Note:</b> RODM high-level load function statement syntax is case sensitive.</p>
                                        <p class="a">The examples of use for the RODM high-level load function statements in this<br>
                                            section are subsets of the load function input statement stream as shown in<br>
                                            Figure 63. These statements create and use the hierarchical pseudo-structure shown<br>
                                            in Figure 64 on page 275. This structure and the associated fields are an example<br>
                                            for explanation purposes only, they are not part of RODM.<br>
                                            </p>
                                        <img src="im29.PNG">
                                        <p class="a"><i>Figure 63. Hierarchical Pseudo-Structure for Examples</i></p>
                                        <img src="im30.PNG">
                                        <p class="a"><i>Figure 64. High-Level Input Statements for Pseudo-Structure</i></p>
                                        <h4 class="heading">MANAGED OBJECT CLASS:</h4>
                                        <h5 class="heading">Purpose</h5>
                                        <p class="a">Use the MANAGED OBJECT CLASS high-level load function statement to define<br>
                                            the hierarchy and create the data model class structure in the RODM data cache.</p>
                                        <p class="a">The following syntax declares class structure that the RODM load function adds to<br>
                                            the RODM data cache. It does not contain keywords for resetting values,<br>
                                            modifying, or deleting part or all of the class structure</p>
                                        <h4 class="heading">Syntax</h4>
                                        <img src="im31.PNG">
                                        <img src="im32.PNG">
                                        <h4 class="heading">Keyword and Parameter Descriptions</h4>
                                        <p class="a"><i>class</i> &nbsp;&nbsp;The name or label of the class that you are defining.
                                        </p>
                                        <p class="a"><b class="bold">PARENT IS</b><i> parent_name</i></p>
                                        <p class="b">The name of the parent class of the class being created.</p>
                                        <p class="a"><i>field type</i></p>
                                        <p class="b">Creates a field with name field of data type type for the class being created.<br>
                                            For a list of valid data types for this field, see “type” on page 301.</p>
                                        <h4 class="heading">PUBLIC|PRIVATE|PUBLIC_INDEXED</h4>
                                        <p class="b">Specifies if the field is a public, a public indexed, or a private field. Public<br>
                                            fields are inherited by children of this class, private fields are not inherited.<br>
                                            For more information about public indexed fields, see “Indexed Fields” on<br>
                                            page 216.</p>
                                        <p class="a"><b class="bold">INIT</b><i>(init_value)</i></p>
                                        <p class="b">An initial value setting for the field. INITIAL can be used instead of INIT. </p>
                                        <h4 class="heading">Example</h4>
                                        <p class="a">
                                            Consider the specification of a class named SystemSoftware that is a child of the<br>
class named Software and has the following fields:<br>
ProductName<br>
ProgramNumber<br>
LatestPTFNumber<br>
CorrespondingAPARNumber<br>
DateApplied<br>
Priority<br>
UseInHost<br>
                                        </p>
                                        <p class="a">Suppose that the initial value for the field named ProgramNumber is None, the<br>
                                            initial value for the field named LatestPTFNumber is UY12345, and the initial value<br>
                                            for the field named Priority is 3. The following MANAGED OBJECT CLASS<br>
                                            statement defines the class named SystemSoftware:</p>
                                        <img src="im33.PNG">
                                        <h4 class="heading">Usage Notes</h4>
                                        <p class="a">Observe the following rules when you specify the<i>init_value </i>associated with the<br>
                                            INIT or INITIAL keyword in a field definition list:</p>
                                        <p class="a">
                                            <ul>
                                                <li>Enclose all values in parentheses</li>
                                                <li>Enclose character values in single quotation marks within the parentheses.</li>
                                                <li>Do not add additional parentheses to values for data types, such as<br>
                                                    METHODSPEC and SELFDEFINING, that are already bound by parentheses.</li>
                                                <li>Enclose non-null GRAPHICVAR values in shift-out and shift-in characters within<br>
                                                    the parentheses.</li>
                                                <li>v Enclose a null GRAPHICVAR value in single quotation marks within the<br>
                                                    parentheses.</li>
                                                
                                                


                                            </ul>
                                        </p>
            <h4 class="heading">CREATE:</h4>
            <h5 class="heading">Purpose</h5>
            <p class="a">Use the CREATE high-level load function statement to create an object of a specific<br>
                class in the RODM data cache.
                </p>
            <h4 class="heading">Syntax</h4>
            <img src="im34.PNG">
            <h4 class="heading">Keyword and Parameter Descriptions</h4>
            <h4 class="heading">INVOKER ::=<i> invoke_value</i></h4>
            <p class="a">The identifier value. The value is ignored by the RODM load function, but<br>
                can be used to number high-level load function statements in your<br>
                definition files.</p>
            <p class="a"><b class="bold">OBJCLASS ::=</b><i> class</i></p>
                <p class="b">The name of the parent class of the object being created</p>

<p class="a"><b class="bold">OBJINST ::= MyName = (CHARVAR) </b><i>object</i></p>
<p class="b">The name of the object being created.</p>
<p class="a"><i>field ::= typed_value</i></p>
<p class="b">Sets the <i>field</i> named field to the value <i>typed_value. </i>For a list of valid data<br>
    types and values, see “typed_value” on page 303.</p>
<h4 class="heading">Example</h4>
<p class="a">Consider the specifications necessary for creating an object to represent system<br>
    software called SDSF. SDSF is a child of the class named SystemSoftware and has<br>
    the following fields and values:<br>
    <ul>
        <li>ProductName with a value of SDSF</li>
        <li> ProgramNumber with a value of 5697-B82</li>
        <li> LatestPTFNumber with a value of UY12903</li>
        <li>CorrespondingAPARNumber with a value of PL45419</li>
        <li>DateApplied with a value of 03/01/97</li>
        <li>UseInHost field that links this object to HostA and HostC</li>
    </ul>
</p>
<p class="a"><b class="bold">Note:</b> HostA and HostC must already exist for the links to be successful.</p>
<p class="a">The following is the statement needed to create the object SDSF:</p>
<img src="im35.PNG">
<p class="a"><i>Figure 65. Create Object Example</i></p>
<h4 class="heading">Usage Notes
</h4>
<p class="a">When specifying the parameters of the OBJINST keyword of the CREATE<br>
    high-level statement you normally specify MyName as the name of the field because<br>
    the MyName field always represents the name of the object. For example:<br>
    OBJINST ::= MyName = (CHARVAR) ’SDSF’;<br></p>
<p class="a">But if you want another of the object's fields to also have the object name as its<br>
    value, you specify that field name instead of MyName in the OBJINST definition. The<br>
    MyName field and that field are then assigned the same value. For example, if you<br>
    want the object name of SDSF assigned as the value of both the MyName and<br>
    ProductName fields of the object, you specify:<br>
    OBJINST ::= ProductName = (CHARVAR) ’SDSF’;</p>
<p class="a">Do not repeat ProductName as a field in the ATTRLIST.</p>
<h4 class="heading">DELETE:</h4>
<h4 class="heading">Purpose</h4>
<p class="a">Use the high-level load function DELETE statement to delete an object from the<br>
    RODM data cache</p>
<h4 class="heading">Syntax</h4>
<img src="im36.PNG">
<h4 class="heading">Keyword and Parameter Descriptions</h4>
<p class="a"><b class="bold">INVOKER ::=</b><i> invoke_value</i></p>
<p class="b">The identifier value. The value is ignored by the RODM load function, but<br>
    can be used to number high-level load function statements in your load<br>
    function input files.</p>
<p class="a"><b class="bold">OBJCLASS ::= </b><i>class</i></p>
<p class="b">The name of the parent class of the object being deleted.</p>
<p class="a"><b class="bold">OBJINST ::= MyName = (CHARVAR) </b><i>object</i></p>
<p class="b">The name of the object being deleted.</p>
<h4 class="heading">Example</h4>
<p class="a">Figure 66 shows a DELETE statement that deletes an object from the data model</p>
<img src="im37.PNG">
<p class="a"><i>Figure 66. Delete Object Example</i></p>
<p class="a">The object to be deleted, SDSF, is specified as a parameter of the OBJINST<br>
    keyword, and the parent class of the object, SystemSoftware, is specified as a<br>
    parameter of the OBJCLASS keyword.</p>
<h4 class="heading">SET:</h4>
<h4 class="heading">Purpose</h4>
<p class="a">Use the SET high-level load function statement to set the values of fields within an<br>
    object in the RODM data cache.</p>
<h4 class="heading">Syntax</h4>
<img src="im38.PNG">
<img src="im39.PNG">
<h4 class="heading">Keyword and Parameter Descriptions</h4>
<p class="a"><b class="bold">INVOKER </b><i>::= invoke_value</i></p>
<p class="b">The identifier value. The value is ignored by the RODM load function, but<br>
    can be used to number high-level load function statements in your load<br>
    function input files.</p>
<p class="a"><b class="bold">MODE </b><i>::= mode_value</i></p>
<p class="b">This value is ignored by the RODM load function, and is assumed to<br>
    always be non-confirmed.</p>
    <p class="a"><b class="bold">OBJCLASS</b><i> ::= class</i></p>
    <p class="b">The name of the parent class of the object for which field values are being<br>
        set.</p>
        <p class="a"><b class="bold">OBJINST ::= MyName = (CHARVAR) </b><i>object</i></p>
        <p class="b">The name of the object for which field values are being set</p>
        <p class="a"><i>field ::= typed_value</i></p>
        <p class="b">The field named field is set to the value typed_value. For a list of valid data<br>
            types and values, see “typed_value” on page 303.</p>
          <p class="a"><i>modifier</i></p> 
          <p class="b">Use this parameter to specify the type of modification. The possible values<br>
            of modifier are:</p>
        <h4 class="heading3">Value Description</h4>
        
        <h4 class="heading3">ADD VALUE</h4>
        <p class="c">Use only for data types of OBJECTLINK or OBJECTLINKLIST to<br>
            create a new link.</p>
        <h4 class="heading3">REMOVE VALUE</h4>
        <p class="c">Use only for data types of OBJECTLINK or OBJECTLINKLIST to<br>
            delete an existing link</p>
        <h4 class="heading3">REPLACE</h4>
        <p class="c">Use for data types other than OBJECTLINK or OBJECTLINKLIST<br>
            to change the value subfield of the specified field to a new value.</p>
       
        <h4 class="heading3">SET TO DEFAULT</h4>
        <p class="c">Use for data types other than OBJECTLINK or OBJECTLINKLIST<br>
            to change the value subfield of the specified field to the default<br>
            value. The default value is the value of the field for the parent<br>
            class.</p>
        <p class="b">If the data type is OBJECTLINK or OBJECTLINKLIST, the default is ADD<br>
            VALUE. For all other data types, the default is REPLACE.</p>
        <h4 class="heading">END</h4>
        <p class="b">The required keyword that identifies the end of the SET high-level load<br>
            function statement.</p>
        <h4 class="heading">Example</h4>
        <p class="a">Consider a SET high-level load function statement where you want to change the<br>
            values of the SDSF object, which is a child of the class named SystemSoftware. In<br>
            particular, you want to make the following changes to the fields of SDSF:<br>
        <ul>
            <li>Change the ProductName field value to SDSF V2.</li>
            <li>Change the ProgramNumber field value to 5697-B82.</li>
            <li>Change the LatestPTFNnumber field value to the default value</li>
            <li>Reset the CorrespondingAPARNumber field value to a blank string. </li>
            <li>Change the DateApplied field value to 03/01/97.</li>
            <li>Unlink the UseSystemSoftware field in the HostA object of Host_Class from the<br>
                UseInHost field.</li>
        </ul></p>
        <p class="a">The statement to set the values of the fields of the SDSF object is shown in<br>
            Figure 67.</p>
    <img src="im40.PNG">
    <p class="a"><i>Figure 67. Set Value of Fields in an Object Example</i></p>
    <h4 class="heading">Usage Notes</h4>
    <p class="a">For definitions of OBJECTLINK and OBJECTLINKLIST fields, the RODM load<br>
        function creates a link if the modification is ADD VALUE and deletes a link if the<br>
        modification is REMOVE VALUE. Additionally, enclose in parentheses the value of<br>
        any fields that specify a data type of either OBJECTLINK or OBJECTLINKLIST.</p>
    <h3 class="heading1">Coding RODM Load Function Primitive Statements</h3>
    <p class="a">This topic of the reference section describes how to code RODM load function<br>
        primitive statements. It provides the syntax and processing logic along with the<br>
        associated syntax rules. It also describes the use of the global character with<br>
        RODM load function primitives.</p>
    <p class="a">The syntax is shown in syntax diagrams.</p>
    <h4 class="heading">Global Character</h4>
    <p class="a">You can use an asterisk (*) as a <i>global character</i> to replace one or more values in<br>
        RODM primitive statements. Each global character is used to substitute for one<br>
        name, class, object, field, or subfield within a RODM primitive statement. When<br>
        the primitive statement is converted to a RODM function, each global character is<br>
        replaced with a corresponding value from the previous primitive on which the<br>
        name, class, object, field, or subfield was explicitly specified. However, the global<br>
        character can not be used to specify a method name.</p>
        <p class="a">When more than one global character is used, it substitutes values from previous<br>
            primitive statements using the same relative position. For example:</p>
        <img src="im41.PNG">
        <p class="a">The global character in the second primitive statement is substituted with <i>ClassA</i><br>
            from the first primitive. The global character in the third primitive statement is<br>
            substituted with <i>UniversalClass</i> from the first primitive. The global character in the<br>
            fourth primitive statement is substituted with <i>ClassB</i> from the third primitive.<br>
            Finally, the two global characters in the fifth primitive statement are substituted<br>
            with <i>ClassB</i> and <i>FieldB_CharVar, </i>respectively, from the third and fourth primitives.</p>
        <p class="a">The global character is intended as a shorthand way of specifying RODM load<br>
            function primitive statements. The RODM processing logic is not changed by use<br>
            of the global character. The global character does not imply grouping of primitive<br>
            statements.</p>
        <h4 class="heading">Syntax Rules for Load Function Primitives</h4>
        <p class="a">Like RODM high-level load function statement syntax, one or more spaces can<br>
            separate parts of a RODM load function primitive.</p>
        <p class="a"><b class="bold">Note:</b> RODM load function primitive syntax is case sensitive</p>
    <p class="a">Syntax rules applying to input columns, quoted strings, double-byte character<br>
        strings, and comments are the same for RODM load function primitive syntax as<br>
        those specified for RODM high-level load function syntax. See “Syntax Rules for<br>
        High-Level Load Function Statements” on page 273.</p>
    <h4 class="heading">Syntax and Processing Logic for Load Function Primitives</h4>
    <p class="a">This is a reference to the syntax and processing logic for the RODM load function<br>
        primitives. The RODM load function primitives are in alphabetical order, and each<br>
        RODM load function primitive has a description containing its name, meaning,<br>
        external syntax, and the implementation logic.</p>
    <h4 class="heading">FORCE_HAS_NO_INSTANCE:</h4>
    <h5 class="heading">Description</h5>
    <p class="a">FORCE_HAS_NO_INSTANCE ensures that there is no object existing under the<br>
        specified class with the specified name. If links to the object exist, they are<br>
        unlinked, and then the object itself is deleted.
        </p>
        <p class="a">This statement might fail to delete an object after failed retries of deleting all the<br>
            links in a class object or all the objects.</p>
        <h4 class="heading">Syntax</h4>
        <img src="im42.PNG">
        <p class="a"><i>object</i> of <i>class</i> is deleted if it exists.</p>
        <h4 class="heading">Syntax Logic for PARSE, LOAD, and VERIFY</h4>
        <p class="a">Carry out the following syntax checks:<br>
            1. Check that class is a valid RODM class name.<br>
            2. Check that object is a valid RODM object name.</p>
        <h4 class="heading">LOAD Logic</h4>
            <p class="a">Perform the following:<br>
                1. Delete object from class.<br>
                 2. If the object cannot be deleted because of links:</p>
                 <p class="b">a. Query the structure of the class.<br>
                    b. Query all link fields.<br>
                    c. For each field with links, delete the links.<br>
                    d. Retry the delete object request.</p>
                <h4 class="heading">VERIFY Logic</h4>
                <p class="a">Check that object of class does not exist</p>
                <h4 class="heading">FORCE_NOT_A_CLASS:</h4>
                <h4 class="heading">Description</h4>
                <p class="a">FORCE_NOT_A_CLASS ensures that there is no class existing with the specified<br>
                    name. If objects of the class exist, they are deleted, meaning that all links to the<br>
                    objects are dropped, that the objects themselves are deleted, and that the class itself<br>
                    is deleted.</p>
                <h4 class="heading">Syntax</h4>
                <img src="im43.PNG">
                <p class="a"><i>class</i> is deleted if it exists.
                </p>
                <h4 class="heading">Syntax Logic for PARSE, LOAD, and VERIFY</h4>
                <p class="a">Check that class is a valid RODM class name.</p>
                <h4 class="heading">LOAD Logic</h4>
                <p class="a">Perform the following:<br>
                    1. Delete class. 2. If the class cannot be deleted because of children, delete the children and retry<br>
                    the delete request.<br>
                    3. If the class cannot be deleted because of objects, delete the objects and retry the<br>
                    delete request.<br>
                    </p>
                    <h4 class="heading">VERIFY Logic</h4>
                    <p class="a">Check that class does not exist.</p>
                    <h4 class="heading">HAS_FIELD:</h4>
                    <h4 class="heading">Description</h4>
                    <p class="a">HAS_FIELD ensures that a class <i>defines </i>a specified public field</p>
                    <h4 class="heading">Syntax</h4>
                    <img src="im44.PNG">
                    <p class="a"><i>class</i> locally defines a field named <i>field</i> of type <i>type.</i></p>
                    <h4 class="heading">Syntax Logic for PARSE, LOAD, and VERIFY</h4>
                    <p class="a">Carry out the following syntax checks:<br>
                        1. Check that class is a valid RODM class name.<br>
                        2. Check that field is a valid RODM field name.<br>
                        3. Check that type is a valid RODM load function data type.</p>
                        <h4 class="heading">LOAD Logic</h4>
                        <p class="a">Check that the <i>class</i> exists, and create <i>field </i>of <i>type</i> for class</p>
                        <h4 class="heading">VERIFY Logic</h4>
                        <p class="a">Check that  <i>class</i>exists, that it locally defines  <i>field </i>, and that the <i>type</i>of this field<br>
                            matches type. </p>
                            <h4 class="heading">HAS_INDEXED_FIELD:</h4>
                            <h4 class="heading">Description</h4>
                            <p class="a">HAS_INDEXED_FIELD ensures that a class defines a specified public indexed<br>
                                field.</p>
                            <h4 class="heading">Syntax</h4>
                            <img src="im45.PNG">
                            <p class="a"><i>class </i>locally defines a <i>field</i> named field of type CHARVAR.</p>
                            <h4 class="heading">Syntax Logic for PARSE, LOAD, and VERIFY</h4>
                            <p class="a">Carry out the following syntax checks:<br>
                                1. Check that class is a valid RODM class name.<br>
                                2. Check that field is a valid RODM field name.<br>
                                3. Check that CHARVAR is a valid RODM load function data type. Only<br>
                                CHARVAR fields can be public indexed.</p>
                            <h4 class="heading">LOAD Logic</h4>
                            <p class="a">Check that the <i>class</i> exists, and create <i>field </i>ofCHARVAR for class.</p>
                            <h4 class="heading">VERIFY Logic</h4>
                            <p class="a">Check that  <i>class</i>exists, that it locally defines  <i>field </i>, and that the <i>type</i>of this field<br>
                              is  CHARVAR. </p>
                              <h4 class="heading">HAS_INSTANCE:</h4>
                              <h4 class="heading">Description</h4>
                              <p class="a">HAS_INSTANCE ensures that a specific object of the specified class exists.
                            </p>
                            <h4 class="heading">Syntax</h4>
                           <img src="im64.PNG">
                            <p class="a"><i>class </i> has an object named <i>object.</i></p>
                            <h4 class="heading">Syntax Logic for PARSE, LOAD, and VERIFY</h4>
                            <p class="a">Carry out the following syntax checks:<br>
                                1. Check that class is a valid RODM class name.<br>
                                2. Check that object is a valid RODM object name.</p>
                                <h4 class="heading">LOAD Logic</h4>
                                <p class="a">Check that the <i>class</i> exists, and create <i>object</i> of class. </p>
                                <h4 class="heading">VERIFY Logic</h4>
                                <p class="a">Check that the <i>class</i> exists, and d that it has an <i>object</i> </p>
                                <h4 class="heading">HAS_NO_FIELD:</h4>
                                <h4 class="heading">Description</h4>
                                <p class="a">HAS_NO_FIELD deletes the specified field from the specified class. Fields cannot<br>
                                    be deleted from classes that have class or object children. Also, inherited fields<br>
                                    cannot be deleted.</p>
                                    <h4 class="heading">Syntax</h4>
                                    <img src="im47.PNG">
                                    <p class="a"><i>field</i> is deleted from the definition of <i>class</i> if it exists and the class has no object<br>
                                        children.</p>
                                <h4 class="heading">Syntax Logic for PARSE, LOAD, and VERIFY</h4>
                                <p class="a">Carry out the following syntax checks:<br>
                                    1. Check that class is a valid RODM class name.<br>
                                    2. Check that field is a valid RODM field name.</p>
                                    <h4 class="heading">LOAD Logic</h4>
                                    <p class="a">Delete <i>field</i> from <i>class</i>.</p>
                                    <h4 class="heading">VERIFY Logic</h4>
                                    <p class="a">Check that <i>field</i> is not defined by <i>class.</i> </p>
                                    <h4 class="heading">HAS_NO_INSTANCE:</h4>
                                    <h4 class="heading">Description</h4>
                                    <p class="a">HAS_NO_INSTANCE ensures that a specific object of a specific class does not<br>
                                        exist. The only imperative used to implement this specification is a simple delete.</p>
                                    <p class="a">If the object is linked to other objects, it cannot be deleted by this primitive alone;<br>
                                        in that case, see “FORCE_HAS_NO_INSTANCE” on page 282.</p>
                                        <h4 class="heading">Syntax</h4>
                                        <img src="im48.PNG">
                                        <p class="a"><i>object of class</i> is deleted if it exists and has no links to other objects.</p>
                                        <h4 class="heading">Syntax Logic for PARSE, LOAD, and VERIFY</h4>
                                        <p class="a">Carry out the following syntax checks:<br>
                                            1. Check that class is a valid RODM class name.<br>
                                            2. Check that object is a valid RODM object name.</p>
                                            <h4 class="heading">LOAD Logic</h4>
                                            <p class="a">Delete <i>object</i> from class. </p>

                                            <h4 class="heading">VERIFY Logic</h4>
                                            <p class="a">Check that<i>object</i> t does not exist in<i>class.</i> </p>
                                            <h4 class="heading">HAS_NO_SUBFIELD:</h4>
                                    <h4 class="heading">Description</h4>
                                    <p class="a">HAS_NO_SUBFIELD ensures that a specific subfield does not exist for the<br>
                                        specified field. Subfields cannot be deleted from classes that have objects. Also,<br>
                                        subfields on inherited fields cannot be deleted.

                                    </p>
                                    <h4 class="heading">Syntax</h4>
                                    <img src="im49.PNG">
                                    <p class="a"><i>subfield</i> is deleted from <i>field</i> of <i>class</i> if it exists and the class has no object children.</p>

                                    <h4 class="heading">Syntax Logic for PARSE, LOAD, and VERIFY</h4>
                                    <p class="a">Carry out the following syntax checks:<br>
                                        1. Check that class is a valid RODM class name.<br>
                                        2. Check that field is a valid RODM field name.<br>
                                        3. Check that subfield is a valid RODM subfield name.<br>
                                    </p>
                                    <h4 class="heading">LOAD Logic</h4>
                                    <p class="a">Delete <i>subfield</i> from <i>field</i> of class.</p>
                                    <h4 class="heading">VERIFY Logic</h4>
                                    <p class="a">Check that <i>subfield</i> is not defined for <i>field</i> of class.</p>
                                    <h4 class="heading">HAS_PARENT:</h4>
                                    <h4 class="heading">Description</h4>
                                    <p class="a">HAS_PARENT ensures that a class exists under the specified parent.</p>
                                    <h4 class="heading">Syntax</h4>
                                    <h4 class="heading">Has_Parent</h4>
                                    <img src="im50.PNG">
                                    <p class="a"><i>child_class</i> must be a child of <i>parent_class.</i></p>
                                    <h4 class="heading">Syntax Logic for PARSE, LOAD, and VERIFY</h4>
                                    <p class="a">Check that the class names follow the rules for class names in RODM.</p>
                                    <h4 class="heading">LOAD Logic</h4>
                                    <p class="a">Create<i>child_class</i>as a child of <i>parent_class.</i></p>
                                    <h4 class="heading">VERIFY Logic</h4>
                                    <p class="a">Check that both <i>child_class</i>and <i>parent_class.</i>exist and that the parent field of<br>
                                        <i>child_class</i> points to<i>parent_class.</i> </p>
                                        <h4 class="heading">HAS_PRV_FIELD:</h4>
                                        <h4 class="heading">Description</h4>
                                        <p class="a">HAS_PRV_FIELD ensures that a class defines a specified private field.
                                        </p>
                                        <h4 class="heading">Syntax</h4>
                                        <img src="im51.PNG">
                                        <p class="a"><i>class </i>locally defines a field named <i>field</i> of type <i>type.</i></p>
                                        <h4 class="heading">Syntax Logic for PARSE, LOAD, and VERIFY</h4>
                                        <p class="a">Carry out the following syntax checks:<br>
                                            1. Check that class is a valid RODM class name.<br>
                                            2. Check that field is a valid RODM field name.<br>
                                            3. Check that type is a valid RODM load function data type.</p>
                                            <h4 class="heading">LOAD Logic</h4>
<p class="a">Check that the class exists, and create field of type for class. </p>
<h4 class="heading">VERIFY Logic</h4>
<p class="a">Check that class exists, that it defines field as private, and that the type of this field<br>
matches type.</p> 
<h4 class="heading">HAS_SUBFIELD:</h4>
                                        <h4 class="heading">Description</h4>
<p class="a">HAS_SUBFIELD ensures that a field of a class has a specified subfield.</p>
<h4 class="heading">Syntax</h4>
<img src="im51.PNG">
<p class="a"><i>field of class</i> has <i>subfield.</i></p>
<h4 class="heading">Syntax Logic for PARSE, LOAD, and VERIFY</h4>
<p class="a">Carry out the following syntax checks:<br>
    1. Check that class is a valid RODM class name.<br>
    2. Check that field is a valid RODM field name.<br>
    3. Check that subfield is a valid RODM subfield name.</p>
    <h4 class="heading">LOAD Logic</h4>
    <p class="a">Check that the class exists, that the field exists on the class, and create subfield of<br>
        type for the field on that class.</p>
        <h4 class="heading">VERIFY Logic</h4>
    <p class="a">Check that class exists, that it locally defines field, and that this field has subfield<br>
        defined.</p>
        <h4 class="heading">HAS_VALUE:</h4>
                                        <h4 class="heading">Description</h4>
                                        <p class="a">HAS_VALUE ensures that a field of a specific object or class has the specified<br>
                                            value.</p>
                                            <h4 class="heading">Syntax</h4>
                                            <img src="im52.PNG">
                                            <p class="a"><i>field of object</i> of class has value <i>typed_value.</i></p>
                                            <h4 class="heading">Syntax Logic for PARSE, LOAD, and VERIFY</h4>
                                            <p class="a">Carry out the following syntax checks:<br>
                                                1. Check that class is a valid RODM class name.<br>
                                                2. Check that object, if specified, is a valid RODM object name.<br>
                                                3. Check that field is a valid RODM field name.<br>
                                                4. Check that typed_value is a valid RODM typed value</p>
                                                <h4 class="heading">LOAD Logic</h4>
                                                <p class="a">Check that the<i>class, object, and field exist, set field of class.object</i> to the type and<br>
                                                    value specified by<i> typed_value, or set field of class</i> to the type and value specified by<br>
                                                    <i>typed_value.</i> </p>
                                                    <h4 class="heading">VERIFY Logic</h4>
                                                    <p class="a">Check that <i>field of class.object</i> has the type and value specified by <i>typed_value</i> or<br>
                                                        check that <i>field of class</i> has the type and value specified by <i>typed_value.</i></p>
                                                        <h4 class="heading">INHERITS:</h4>
                                                        <h4 class="heading">Description</h4> 
                                                        <p class="a">INHERITS ensures that a specific field of the specified object or class is not locally<br>
                                                            defined.</p>  
                                                            <h4 class="heading">Syntax</h4>
            <img src="im53.PNG">
            <h4 class="heading">Syntax Logic for PARSE, LOAD, and VERIFY</h4>
            <p class="a">Carry out the following syntax checks:<br>
                1. Check that class is a valid RODM class name.<br>
                2. Check that object, if specified, is a valid RODM object name.<br>
                3. Check that field is a valid RODM field name.</p>
                <h4 class="heading">LOAD Logic</h4>
                <p class="a">Revert <i>field.</i> If a local value is present, it is deleted.</p>
                <h4 class="heading">VERIFY Logic</h4>
                <p class="a">Check that the value of <i>field </i>is inherited.

                </p>
                <h4 class="heading">INVOKED_WITH:
                </h4>
                <h4 class="heading">Description</h4>
                <p class="a">INVOKED_WITH runs a named object-specific method or an object-independent<br>
                    method.<br>
                    A maximum of 8 parameters can be specified with sd_parm.</p>
                    <h4 class="heading">Syntax</h4>
                    <h4 class="heading">Invoked_With</h4>
                    <img src="im54.PNG">
                    <h4 class="heading">Syntax Logic for PARSE, LOAD, and VERIFY</h4>
                    <p class="a">Carry out the following syntax checks: <br>
                        For a named object-specific method:<br>
                        1. Check that class is a valid RODM class name.<br>
                        2. Check that object, if specified, is a valid RODM object name.<br>
                        3. Check that field is a valid RODM field name.<br>
                        4. Check that sd_parm is a valid SELFDEFINING value. <br>
                         For an object-independent method:<br>
                        1. Check that method_name is a valid RODM method name.<br>
                        2. Check that sd_parm is a valid SELFDEFINING value.</p>
                        <h4 class="heading">LOAD Logic</h4>
                        <p class="a">For a named object-specific method, trigger the method specified by<i>class.object.field<br>
                            or by class..field</i> with the parameters specified in <i>sd_parm.</i> The data type of the field<br>
                            must be MethodSpec.</p>
                        <p class="a">For an object-independent method, trigger the <i>method_name</i> with the parameters<br>
                            specified in <i>sd_parm.</i> The <i>method_name </i>must be the name of an object of the<br>
                            EKG_Method class.</p>
                            <h4 class="heading">VERIFY Logic</h4>
                            <p class="a">None.</p>
                            <h4 class="heading">IS_LINKED_TO:</h4>
                            <h4 class="heading">Description</h4>
                            <p class="a">IS_LINKED_TO ensures that two objects are linked by the specified fields. The<br>
                                fields must be of type OBJECTLINK or OBJECTLINKLIST.</p>
                                <h4 class="heading">Syntax</h4>
                                <img src="im55.PNG">
                                <h4 class="heading">Syntax Logic for PARSE, LOAD, and VERIFY</h4>
                                <p class="a">Carry out the following syntax checks:<br>
                                    1. Check that <i>class_1 </i>is a valid RODM class name.<br>
                                    2. Check that <i>class_2</i> is a valid RODM class name.<br>
                                    3. Check that <i>object_1</i> is a valid RODM object name.<br>
                                    4. Check that <i>object_2</i> is a valid RODM object name<br>.
                                    5. Check that <i>field_1</i> is a valid RODM field name.<br>
                                    6. Check that <i>field_2</i> is a valid RODM field name.<br>
                                    </p>
                                    <h4 class="heading">LOAD Logic</h4>
                                    <p class="a">Link <i>field_1 of class_1.object_1 to field_2 of class_2.object_2.</i></p>
                                    <h4 class="heading">VERIFY Logic</h4>
                                    <p class="a">Query <i>field_1 of class_1.object_1</i> and check that <i>field_2 of class_2.object_2</i> is in the list<br>
                                        of linked fields that is returned by the query. </p>
                                    <h4 class="heading">IS_NOT_LINKED_TO:</h4>
                                    <h4 class="heading">Description</h4>
                                    <p class="a">IS_NOT_LINKED_TO ensures that two objects are not linked by the specified<br>
                                        fields.</p>
                                        <h4 class="heading">Syntax</h4>
                                        <img src="im56.PNG">
                                        <h4 class="heading">Syntax Logic for PARSE, LOAD, and VERIFY</h4>
                                        <p class="a">Carry out the following syntax checks:<br>
                                            1. Check that <i>class_1 </i>is a valid RODM class name.<br>
                                            2. Check that <i>class_2</i> is a valid RODM class name.<br>
                                            3. Check that <i>object_1</i> is a valid RODM object name.<br>
                                            4. Check that <i>object_2</i> is a valid RODM object name<br>.
                                            5. Check that <i>field_1</i> is a valid RODM field name.<br>
                                            6. Check that <i>field_2</i> is a valid RODM field name.<br>
                                            </p>
                                            <h4 class="heading">LOAD Logic</h4>
                                            <p class="a">Unlink <i>field_1 of class_1.object_1 to field_2 of class_2.object_2.</i></p>
                                            <h4 class="heading">VERIFY Logic</h4>
                                            <p class="a">Query <i>field_1 of class_1.object_1</i> and check that <i>field_2 of class_2.object_2</i> is not in the list<br>
                                                of linked fields that is returned by the query. </p>
                                            <h4 class="heading">NOT_A_CLASS:</h4>
                                            <h4 class="heading">Description</h4>
                                            <p class="a">NOT_A_CLASS ensures that there is no class existing with the specified name. The<br>
                                                only imperative used to implement this specification is a simple delete; if a class<br>
                                                has objects, it cannot be deleted with this primitive alone. Instead,<br>
                                                FORCE_NOT_A_CLASS must be used or the objects must first be deleted.</p>
                                                <h4 class="heading">Syntax</h4>
                                                <img src="im57.PNG">
                                                <h4 class="heading">Syntax Logic for PARSE, LOAD, and VERIFY</h4>
                                            <p class="a">Check that class is a valid RODM class name.</p>
                                            <h4 class="heading">LOAD Logic</h4>
                                            <p class="a">Delete <i>class.</i></p>
                                            <h4 class="heading">VERIFY Logic</h4>
                                            <p class="a">Check that <i>class.</i> does not exist</p>
                                            <h4 class="heading">SUBFIELD_HAS_VALUE:</h4>
                                            <h4 class="heading">Description</h4>
                                            <p class="a">SUBFIELD_HAS_VALUE ensures that a subfield has the specified value.</p>
                                            <h4 class="heading">Syntax</h4>
                                            <img src="im58.PNG">
                                            <h4 class="heading">Syntax Logic for PARSE, LOAD, and VERIFY</h4>
                                            <p class="a">Carry out the following syntax checks:<br>
                                                1. Check that <i>class</i> is a valid RODM class name.<br>
                                                2. Check that  <i>object,</i>  if specified, is a valid RODM object name.<br>
                                                3. Check that  <i>field</i>  is a valid RODM field name.<br>
                                                4. Check that  <i>subfield </i> is a valid RODM subfield name.<br>
                                                5. Check that  <i>typed_value</i>  is a valid RODM typed value.</p>
                                                <h4 class="heading">LOAD Logic</h4>
                                                <p class="a">Set <i>subfield of field of class</i> to the type and value of<i> typed_value or set subfield of field<br>
                                                    of class</i>.object to the type and value of typed_value.</p>
                                                    <h4 class="heading">VERIFY Logic</h4>
                                                    <p class="a">Check that <i>subfield of field of class</i> has the type and value of <i>typed_value or check<br>
                                                        that subfield of field of class.object</i> has the type and value of <i>typed_value. </i></p>
                <h4 class="heading">SUBFIELD_INHERITS:</h4>
                <h4 class="heading">Description</h4>
                <p class="a">SUBFIELD_INHERITS ensures that a specific subfield of the specified object or<br>
                    class is not locally defined.</p>
                    <h4 class="heading">Syntax</h4>
                    <img src="im59.PNG">
                    <h4 class="heading">Syntax Logic for PARSE, LOAD, and VERIFY</h4>
                    <p class="a">Carry out the following syntax checks:<br>
                        1. Check that <i>class</i> is a valid RODM class name.<br>
                        2. Check that  <i>object,</i>  if specified, is a valid RODM object name.<br>
                        3. Check that  <i>field</i>  is a valid RODM field name.<br>
                        4. Check that  <i>subfield </i> is a valid RODM subfield name.<br>
                        5. Check that  <i>typed_value</i>  is a valid RODM typed value.</p>
                        <h4 class="heading">LOAD Logic</h4>
                        <p class="a">Revert <i>subfield_name.</i></p>
                        <h4 class="heading">VERIFY Logic</h4>
                        <p class="a">Check that the value of <i>subfield_name</i> is inherited.</p>
                        <h3 class="heading1">Common Syntactic Elements</h3>
                        <p class="a">The RODM load function primitive and RODM high-level load function statements<br>
                            use common syntactic elements such as class, which is a class name. These simple<br>
                            common elements are described here along with descriptions of common text and<br>
                            numeric character strings.
                            </p>
                        <p class="a">These elements and character strings are described using syntax diagrams.</p>
                        <h4 class="heading">Syntax for Common Syntactic Elements</h4>
                        <p class="a">The following sections describe the common syntactic elements for the RODM load<br>
                            function.</p>
                            <h4 class="heading">chars:<br>
                                Purpose</h4>

                        <p class="a">A character string, which can be one or more printable single-byte or double-byte<br>
characters.</p>
<h4 class="heading">Format<br><br>
    Chars</h4>
    <img src="im60.PNG">
    <h4 class="heading">Usage Notes</h4>
    <p class="a">A double-byte character string must be preceded by a shift-out character and<br>
        ended with a shift-in character.</p>
    <h4 class="heading">char_literal:<br>
        Purpose</h4>
        <p class="a">A character string within single quotation marks.</p>
        <h4 class="heading">Format<br><br>
            Char_Literal</h4>
            <img src="im61.PNG">
            <h4 class="heading">Usage Notes</h4>
            <p class="a">To indicate a single quotation mark (') within a <i>char_literal,</i> use two immediately<br>
                adjacent single quotation marks with no spaces or new lines between the two<br>
                single quotation marks. This is the traditional doubled quote </p>
                <p class="a">You can continue <i>char_literal</i> primitives across lines of input by enclosing the pieces<br>
                    on each line within single quotation marks.</p>
                    <h4 class="heading">class:</h4>
                    <h4 class="heading">Purpose</h4>
                    <p class="a">A valid RODM class name.</p>
                    <h4 class="heading">Format</h4>
                    <h4 class="heading">class</h4>
                    <img src="im62.PNG">
                    <h4 class="heading">Usage Notes</h4>
                    <p class="a">If the class name contains any non-alphanumeric character, enclose the class name<br>
                        in single quotation marks</p>
                    <h4 class="heading">class_list:<br>
                        Purpose</h4>
                        <p class="a">A list of RODM class names, separated by commas.</p>
                    <h4 class="heading">Format</h4>
                    <h4 class="heading">class_list</h4>
                    <img src="im63.PNG">
                    <h4 class="heading">classlink_list:<br>
                        Purpose</h4>
                        <p class="a">A list of class links separated by commas. Each class link is a concatenation of a<br>
                            class name, a period, and a field name.</p>
                            <h4 class="heading">Format</h4>
                    <h4 class="heading">classlink_list</h4>
                    <img src="im64.PNG">
                    <h4 class="heading">dbcs_literal:<br>
                        Purpose</h4>
                        <p class="a">A concatenation of a shift-out character, one or more valid double-byte characters,<br>
                            and a shift-in character.
                            </p>
                        <h4 class="heading">Format<br><br>
                            DBCS_Literal</h4>
                            <img src="im65.PNG">
                            <h4 class="heading">Parameter Descriptions</h4>
                            <p class="a"><i>shift-out_char</i></p>
                            <p class="b">A value of X'0E'.</p>
                            <p class="a"><i>double-byte_char</i></p>
                            <p class="b">Four hexadecimal characters (two bytes) representing one printable<br>
                                character.</p>
                            <p class="a"><i>shift-in_char</i></p>
                            <p class="b">
                                A value of X'0F'.</p>
                                <h4 class="heading">Usage Notes</h4>
                                <p class="a">Double-byte text must begin with shift-out and end with shift-in. If the text<br>
                                    continues for multiple lines, the double-byte text on each line must be within the<br>
                                    shift-out and shift-in pair. The valid double-byte characters are the same as those<br>
                                    for the GraphicVar data type; see “GraphicVar” on page 227.</p>
                                <h4 class="heading">digits:</h4>

                                <h4 class="heading">Purpose</h4>
                                <p class="a">The concatenation of any of the decimal digits: 0, 1, 2, 3, 4, 5, 6, 7, 8, or 9.</p>
                                <h4 class="heading">Format<br><br>
                                    Digits</h4>
                                    <img src="im66.PNG">
                                    <h4 class="heading">field:</h4>
                                    <h4 class="heading">Purpose</h4>
                                    <p class="a">A valid RODM field name.</p>
                                    <h4 class="heading">Format</h4>
                                    <h4 class="heading">field</h4>
                                    <img src="im67.PNG">
                                    <h4 class="heading">Usage Notes</h4>
                                    <p class="a">If the field name contains any non-alphanumeric character, enclose the field name<br>
                                        in single quotation marks.</p>
                                        <h4 class="heading">float_constant:</h4>

                                        <h4 class="heading">Purpose</h4>
                                        <p class="a">A floating-point constant is a concatenation of a numeric literal, an optional<br>
                                            decimal fraction, and an optional signed floating-point exponent digit.</p>

<h4 class="heading">Format</h4>
<h3 class="heading">Float_Constant</h3>
<img src="im68.PNG">
<h4 class="heading">hex_chars:<br>
    Purpose</h4>
    <p class="a">The concatenation of hexadecimal character pairs, where each pair represents one<br>
        byte.</p>
        <h4 class="heading">Format</h4>
        <h3 class="heading">  Hex_Chars</h3>
        <img src="im69.PNG">
        <h4 class="heading">hex_literal:<br>
            Purpose</h4>
            <p class="a">One or more pairs of hexadecimal characters, within the hex delimiters.<br>
            </p>
            <h4 class="heading">Format</h4>
<h3 class="heading">Hex_Literal</h3>
<img src="im70.PNG">
<h4 class="heading">il_parm:<br>
    Purpose</h4>
    <p class="a">An INDEXLIST parameter is a list of typed values. Each typed value can be either<br>
        an ANONYMOUSVAR data type value or a CHARVAR data type value. However,<br>
         CHARVAR values are converted to ANONYMOUSVAR values by the RODM load<br>
        function.</p>
        <h4 class="heading">Format</h4>
<h3 class="heading">Il_Parm</h3>
<img src="im71.PNG">
<h4 class="heading">method_spec:<br>
    Purpose</h4>
<p class="a">A method specification is a concatenation of a method name and a<br>
    SELFDEFINING parameter within parentheses.
    </p>
    <h4 class="heading">Format</h4>
    <h3 class="heading">method_spec</h3>
    <img src="im72.PNG">
    <h4 class="heading">numeric_literal:<br>
        Purpose</h4>
        <p class="a">A signed string of numeric digits</p>
        <h4 class="heading">Format</h4>
        <h3 class="heading">Numeric</h3>
        <img src="im73.PNG">
        <h4 class="heading">object:<br>
            Purpose</h4>
            <p class="a">A valid RODM object name.
            </p>
            <h4 class="heading">Format</h4>
        <h3 class="heading">object</h3>
        <img src="im74.PNG">
        <h4 class="heading">Usage Notes</h4>
        <p class="a">If the object name contains any non-alphanumeric character, enclose the object<br>
            name in single quotation marks.</p>
        <h4 class="heading">objectid_list:<br>
            Purpose</h4>
            <p class="a">A list of object IDs separated by commas. An object ID is a concatenation of a class<br>
                name, a period, and an object name.</p>
                <h4 class="heading">Format</h4>
                <h3 class="heading">objectid_list</h3>
                <img src="im75.PNG">
                <h4 class="heading">objectlink_list:</h4>
                <h4 class="heading">Purpose</h4>
                <p class="a">An <i>objectlink_list</i> is a list of object links separated by spaces. An object link is a<br>
                    concatenation of a class name, a period, an object name, a period, and a field name<br>
                    within parentheses.</p>
                    <h4 class="heading">Format</h4>
                    <h3 class="heading">objectlink_list</h3>
                    <img src="im76.PNG">
                <h4 class="heading">objectlink_list:</h4>

                <h4 class="heading">recipient_spec:<br>
                    Purpose</h4>
                    <p class="a">A recipient specification is a concatenation of two character literals and a literal, all<br>
                        of which must be exactly eight bytes in length.</p>
                        <h4 class="heading">Format</h4>
                        <h3 class="heading">recipient_spec</h3>
                        <img src="im77.PNG">
                        <h4 class="heading">Usage Notes</h4>
                        <p class="a">The first character literal is an <i>application_id.</i> The second character literal is a<br>
                            <i>subscribe_id. </i>If either character literal is less than eight bytes long, the literal will be<br>
                            left-justified and padded with blanks on the right by the RODM load function to<br>
                            make them eight bytes long. There must be sixteen hex digits for the hex data to<br>
                            be eight bytes long</p>
                            <h4 class="heading">sd_parm:<br>
                                Purpose</h4>
                                <p class="a">A SELFDEFINING parameter is a list of typed values, optionally separated by<br>
                                    blanks, within parentheses.</p>
                                    <h4 class="heading">Format</h4>
                                    <h3 class="heading">sd_parm</h3>
                                    <img src="im78.PNG">
                                    <h4 class="heading">subfield:<br>
                                        Purpose</h4>
                                        <p class="a">A predefined subfield name.</p>



        



                                    


                        

                




                


                                            




                                    





                    

                











                                        









                                    


                                



                            




                

    




                                        
                                        








                            




            
            







                            
                                    



                            

                        

                
            


    


                                        




                                                    


                                    
                                    
                                        











                        








                











                            
                            

                            
                        
                    

        

                            






                    



                    
                
        
        




        
        

        
        
        </body>
        </html>